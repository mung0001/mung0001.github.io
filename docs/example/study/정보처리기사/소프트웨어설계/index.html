<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="플랫폼 ( Platform )  애플리케이션을 구동시키는 데 필요한 하드웨어와 소프트웨어의 결합 동일 플랫폼 내에서의 상호 호환이 가능하도록 만들어진 결합체를 의미 소프트웨어의 개발과 운영비용을 감소시키고, 생산성이 향상 동일 플랫폼의 커뮤니티가 형성되고 네트워크 효과를 유발  플랫폼의 유형  유형 | 설명 | 사례------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------싱글 사이드 플랫폼 (Single-Side platform) | 제휴 관계를 통해 소비자와 공급자를 연결하는 형태 | 아이튠즈, 안드로이드 마켓투 사이드 플랫폼 (Two-Side Platform) | 두 그룹을 중개하고 모두에게 개방하는 형태 | 소개팅 앱멀티 사이트 플랫폼 (Multi-Side Platform) | 다양한 이해관계 그룹을 연결하여 중개하는 형태 | 페이스북, 인스타그램 플랫폼의 기능 분석  플랫폼 성능 분석을 통해 사용자의 서비스 이용 시 적정성을 알 수 있다."><meta property="og:title" content="" />
<meta property="og:description" content="플랫폼 ( Platform )  애플리케이션을 구동시키는 데 필요한 하드웨어와 소프트웨어의 결합 동일 플랫폼 내에서의 상호 호환이 가능하도록 만들어진 결합체를 의미 소프트웨어의 개발과 운영비용을 감소시키고, 생산성이 향상 동일 플랫폼의 커뮤니티가 형성되고 네트워크 효과를 유발  플랫폼의 유형  유형 | 설명 | 사례------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------싱글 사이드 플랫폼 (Single-Side platform) | 제휴 관계를 통해 소비자와 공급자를 연결하는 형태 | 아이튠즈, 안드로이드 마켓투 사이드 플랫폼 (Two-Side Platform) | 두 그룹을 중개하고 모두에게 개방하는 형태 | 소개팅 앱멀티 사이트 플랫폼 (Multi-Side Platform) | 다양한 이해관계 그룹을 연결하여 중개하는 형태 | 페이스북, 인스타그램 플랫폼의 기능 분석  플랫폼 성능 분석을 통해 사용자의 서비스 이용 시 적정성을 알 수 있다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mung0001.github.io/docs/example/study/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EC%84%A4%EA%B3%84/" />


<title>정근이가 잘 할거에요</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.63eb88daa545365405ecdbb21033286a325c60a36cfa6d22d21e7c3bc9286941.css" integrity="sha256-Y&#43;uI2qVFNlQF7NuyEDMoajJcYKNs&#43;m0i0h58O8koaUE=">
<script defer src="/en.search.min.d11ff76947414aa5b47b63721f00c24d04c37fdcb979cd46860e080b5fa9c2c5.js" integrity="sha256-0R/3aUdBSqW0e2NyHwDCTQTDf9y5ec1Ghg4IC1&#43;pwsU="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><span>정근이가 잘 할거에요</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  

  
  





 
  
    




  
  <ul>
    
      
        

  <li class="book-section-flat" >
    

  
  <a href="/docs/example/" class="">Home</a>
  


    




  
  <ul>
    
      
        

  <li>
    

  
  <a href="/docs/example/main_01/" class="">Main 01</a>
  


    




  
  <ul>
    
      
        <li>

  
  <a href="/docs/example/main_01/main_01/" class="">With ToC</a>
  

</li>
      
    
  </ul>
  



  </li>


      
    
      
        

  <li>
    

  
  <a href="/docs/example/collapsed/" class="collapsed ">Collapsed</a>
  


    






  </li>


      
    
      
        

  <li>
    

  
  <a href="/docs/example/main_02/" class="collapsed ">Main 02</a>
  


    






  </li>


      
    
      
        

  <li>
    

  
  <a href="/docs/example/study/" class="collapsed ">Study</a>
  


    




  
  <ul>
    
      
        

  <li>
    

  
  <a href="/docs/example/study/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/" class="">정보처리기사</a>
  


    




  
  <ul>
    
      
        <li>

  
  <a href="/docs/example/study/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EC%84%A4%EA%B3%84/" class="active">소프트웨어설계</a>
  

</li>
      
    
  </ul>
  



  </li>


      
    
  </ul>
  



  </li>


      
    
      
        

  <li>
    

  
  <a href="/docs/example/test/" class="collapsed ">Test</a>
  


    






  </li>


      
    
      
        

  <li>
    

  
  <a href="/docs/example/cloud/" class="">Cloud</a>
  


    




  
  <ul>
    
  </ul>
  



  </li>


      
    
      
        

  <li>
    

  
  <a href="/docs/example/database/" class="">Data Base</a>
  


    




  
  <ul>
    
  </ul>
  



  </li>


      
    
      
        

  <li>
    

  
  <a href="/docs/example/network/" class="">Network</a>
  


    




  
  <ul>
    
  </ul>
  



  </li>


      
    
      
        

  <li>
    

  
  <a href="/docs/example/securty/" class="">Securty</a>
  


    




  
  <ul>
    
  </ul>
  



  </li>


      
    
      
        

  <li>
    

  
  <a href="/docs/example/system/" class="">System</a>
  


    




  
  <ul>
    
  </ul>
  



  </li>


      
    
  </ul>
  



  </li>


      
    
  </ul>
  



  














  
<ul>
  
  <li>
    <a href="/posts/" >
        Blog
      </a>
  </li>
  
</ul>







</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>소프트웨어설계</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#플랫폼--platform-">플랫폼 ( Platform )</a>
      <ul>
        <li><a href="#플랫폼의-유형"><strong>플랫폼의 유형</strong></a></li>
        <li><a href="#플랫폼의-기능-분석"><strong>플랫폼의 기능 분석</strong></a></li>
        <li><a href="#플랫폼-기능-분석-절차"><strong>플랫폼 기능 분석 절차</strong></a></li>
        <li><a href="#플랫폼-기능-분석-기법"><strong>플랫폼 기능 분석 기법</strong></a></li>
      </ul>
    </li>
    <li><a href="#운영체제-operating-system-분석">운영체제 (Operating System) 분석</a>
      <ul>
        <li><a href="#운영체제의-현행-시스템-분석"><strong>운영체제의 현행 시스템 분석</strong></a></li>
        <li><a href="#운영체제의-종류-및-특성"><strong>운영체제의 종류 및 특성</strong></a></li>
      </ul>
    </li>
    <li><a href="#네트워크-분석">네트워크 분석</a>
      <ul>
        <li><a href="#osi-7계층"><strong>OSI 7계층</strong></a></li>
      </ul>
    </li>
    <li><a href="#dbms-분석">DBMS 분석</a>
      <ul>
        <li><a href="#dbms의-기능"><strong>DBMS의 기능</strong></a></li>
        <li><a href="#dbms의-현행-시스템-분석"><strong>DBMS의 현행 시스템 분석</strong></a></li>
      </ul>
    </li>
    <li><a href="#비즈니스-융합">비즈니스 융합</a>
      <ul>
        <li><a href="#비즈니스-융합-유형"><strong>비즈니스 융합 유형</strong></a></li>
        <li><a href="#비즈니스-융합-분석-절차"><strong>비즈니스 융합 분석 절차</strong></a></li>
      </ul>
    </li>
    <li><a href="#요구분석의-개념">요구분석의 개념</a></li>
    <li><a href="#uml-unified-modeling-language">UML (Unified Modeling Language)</a>
      <ul>
        <li><a href="#uml-특징"><strong>UML 특징</strong></a></li>
        <li><a href="#uml-구성요소"><strong>UML 구성요소</strong></a></li>
        <li><a href="#uml-다이어그램"><strong>UML 다이어그램</strong></a></li>
      </ul>
    </li>
    <li><a href="#애자일-agile">애자일 (Agile)</a>
      <ul>
        <li><a href="#애자일-선언문"><strong>애자일 선언문</strong></a></li>
        <li><a href="#애자일-방법론-유형"><strong>애자일 방법론 유형</strong></a></li>
        <li><a href="#애자일과-전통적-방법론-비교"><strong>애자일과 전통적 방법론 비교</strong></a></li>
      </ul>
    </li>
    <li><a href="#모델링-modeling기법">모델링 (Modeling)기법</a>
      <ul>
        <li><a href="#모델링의-절차"><strong>모델링의 절차</strong></a></li>
        <li><a href="#분석-자동화-도구"><strong>분석 자동화 도구</strong></a></li>
        <li><a href="#요구사항-관리-도구"><strong>요구사항 관리 도구</strong></a></li>
        <li><a href="#요구사항-관리-도구의-종류"><strong>요구사항 관리 도구의 종류</strong></a></li>
      </ul>
    </li>
    <li><a href="#ui-user-interface">UI (User Interface)</a>
      <ul>
        <li><a href="#ui-유형"><strong>UI 유형</strong></a></li>
        <li><a href="#ui-분야"><strong>UI 분야</strong></a></li>
        <li><a href="#ui-설계-원칙"><strong>UI 설계 원칙</strong></a></li>
        <li><a href="#ui-표준"><strong>UI 표준</strong></a></li>
        <li><a href="#프레임-세트-적용"><strong>프레임 세트 적용</strong></a></li>
        <li><a href="#ui지침-guideline"><strong>UI지침 (Guideline)</strong></a></li>
        <li><a href="#ui-설계-프로세스"><strong>UI 설계 프로세스</strong></a></li>
      </ul>
    </li>
    <li><a href="#감성공학">감성공학</a>
      <ul>
        <li><a href="#감성공학의-접근-방법"><strong>감성공학의 접근 방법</strong></a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h2 id="플랫폼--platform-">플랫폼 ( Platform )</h2>
<ul>
<li>애플리케이션을 구동시키는 데 필요한 <strong>하드웨어와 소프트웨어의 결합</strong></li>
<li>동일 플랫폼 내에서의 상호 호환이 가능하도록 만들어진 결합체를 의미</li>
<li>소프트웨어의 <strong>개발과 운영비용을 감소시키고, 생산성이 향상</strong></li>
<li>동일 플랫폼의 커뮤니티가 형성되고 네트워크 효과를 유발</li>
</ul>
<h3 id="플랫폼의-유형"><strong>플랫폼의 유형</strong></h3>
<pre><code>    유형                                               | 설명                                                                   | 사례
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    싱글 사이드 플랫폼 (Single-Side platform)           | 제휴 관계를 통해 소비자와 공급자를 연결하는 형태                           | 아이튠즈, 안드로이드 마켓
    투 사이드 플랫폼 (Two-Side Platform)                | 두 그룹을 중개하고 모두에게 개방하는 형태                                 | 소개팅 앱
    멀티 사이트 플랫폼 (Multi-Side Platform)            | 다양한 이해관계 그룹을 연결하여 중개하는 형태                              | 페이스북, 인스타그램
</code></pre>
<h3 id="플랫폼의-기능-분석"><strong>플랫폼의 기능 분석</strong></h3>
<ul>
<li>플랫폼 성능 분석을 통해 사용자의 <strong>서비스 이용 시 적정성</strong>을 알 수 있다.</li>
<li>사용자 요구사항 중 성능에 대한 개선요청 항목은 현재 시스템 플랫폼 성능이 느린 것으로 제기될 가능성이 높음</li>
</ul>
<h3 id="플랫폼-기능-분석-절차"><strong>플랫폼 기능 분석 절차</strong></h3>
<pre><code>    순서              | 절차                                       | 설명
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    1                 | 현행 플랫폼 자료 수집                       | 현행 시스템 담당자 제시 자료와 인터뷰를 통해 필요 자료 수집/ 파악
    2                 | 수집 자료 분석                             | 수집된 자료에 산발적으로 존재하는 정보들의 취합/ 정제 작업을 실시
    3                 | 결과 산출물 작성                            | 다양한 이해관계자 그룹을 연결하여 중개
</code></pre>
<h3 id="플랫폼-기능-분석-기법"><strong>플랫폼 기능 분석 기법</strong></h3>
<pre><code>  기법              | 설명                                                      | 산출물
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  사용자 인터뷰      | 현행 플랫폼 사용자 인터뷰를 통해 속도의 적정성 확인           | 인터뷰 결과서
  성능 테스트        | 현행 플랫폼을 대상으로 성능, 부하 테스트를 수행              | 성능 테스트, 부하 테스트 결과서
  산출물 점검        | 현재 플랫폼과 유사한 타사 제품의 성능 자료 등을 분석          | 벤치마킹 테스트 결과서
</code></pre>
<h2 id="운영체제-operating-system-분석">운영체제 (Operating System) 분석</h2>
<ul>
<li>하드웨어 및 소프트웨어 자원을 효율적으로 관리하며 <strong>공통된 기능을 제공</strong>하는 소프트웨어</li>
</ul>
<h3 id="운영체제의-현행-시스템-분석"><strong>운영체제의 현행 시스템 분석</strong></h3>
<pre><code>  관점                  | 고려사항                      | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  품질 측면             | 신뢰도                        | 장기간 시스템 운영 시 운영체제의 장래 발생 가능성,, 운영체제의 버그로 인한 재기동 여부
                       | 성능                          | 대규모 및 대량 파일 작업 (배치 작업 처리), 지원 가능한 메모리 크기(Bit)
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  지원 측면             | 기술지원                      | 공급사들의 안정적인 기술 지원
                       | 주변기기                       | 설치 가능한 하드웨어, 다수의 주변 기기 지원 여부
                       | 구축비용                       | 지원 가능한 하드웨어 비용, 설치할 응용 프로그램의 라이센스, 유지 및 관리 비용
</code></pre>
<h3 id="운영체제의-종류-및-특성"><strong>운영체제의 종류 및 특성</strong></h3>
<ul>
<li>
<p>리눅스 기반 시스템이 하드웨어 및 소프트웨어 소유 비용이 가장 적게 소요된다.</p>
</li>
<li>
<p>유지 및 관리 비용 측면에서는 윈도우즈(Windows) 기반 시스템이 강점을 가진다.</p>
</li>
<li>
<p>안정적이고 신뢰할 수 있으며 대용량 처리를 위해서는 유닉스기반 시스템이 선호된다.</p>
<pre><code> 구분                      | 종류                                  | 저작자                                                | 특징
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PC                      | 윈도우즈 (Windows)                    | Microsoft                                             | 중. 소규모 서버, 일반 PC 등 유지, 관리 비용 장점
                         | 유닉스 (UNIX)                         | IBM, HP, SUN                                          | 대용량 처리, 안정성 높은 엔터프라이즈 급 서버
                         | 리눅스 (Linux)                        | Linus Torvalds                                        | 중/ 대규모 서버 대상, 높은 보안성 제공
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  모바일                    | 안드로이드                             | Google                                                | 스마트폰, 태블릿PC, 다양한 기기의 호환성 제공
                        | IOS                                   | Apple                                                 | 스마트폰, 태블릿PC, 높은 보안성과 고성능 제공
</code></pre>
</li>
</ul>
<h2 id="네트워크-분석">네트워크 분석</h2>
<ul>
<li>컴퓨터 장치들을 노드 간 연결(데이터 링크)을 사용하여 <strong>서로에게 데이터를 교환</strong>하는 기술</li>
<li>데이터 링크들은 광케이블과 같은 유선 매체 또는 와이파이(Wi-Fi)와 같은 무선 매체를 통해 성립</li>
<li>백본망, 라우터, 스위치, 게이트 웨이, 방화벽 등을 대상으로 분석</li>
<li>물리적인 위치 관계 파악, 조직 내 보안 취약성 분석 및 대응이 쉽다.</li>
<li>현행시스템이 구성된 네트워크 구조를 네트워크 구성도를 통해 분석 및 네트워크 구성도의 작성을 통해 서버 위치, 서버 간 연결 방식을 파악할 수 있다.</li>
</ul>
<h3 id="osi-7계층"><strong>OSI 7계층</strong></h3>
<pre><code>    계층                                       | 설명                                                                      | 프로토콜                                  | 전송단위
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    응용 계층 (Application Layer)               | 사용자와 네트워크 간 응용서비스 연결, 데이터 생성                            | HTTP, FTP                                | Data
    표현계층 (Presentaion Layer)                | 데이터 형식 설정, 부호 교환, 암/ 복호화                                     | JPEG, MPEG                               
    세션 계층 (Session Layer)                   | 연결 접속, 동기 제어                                                       | SSH, TLS                                    
    전송 계층 (Transport Layer)                 | 신뢰성 있는 통신 보장, 데이터 분할, 재조립, 흐름 제어, 오류 제어, 혼잡 제어    | TCP, UDP                                | Segment
    네트워크 계층 (Network Layer)                | 단말기 간 데이터 전송을 위한 최적화된 경로 제공                              | IP, ICMP                                 | Packet
    데이터링크 계층 (Data Link Layer)            | 인접 시스템 간 데이터 전송, 전송 오류 제어, 오류 검출/ 재전송                | Ethernet                                 | Frame
    물리 계층 (Physical Layer)                  | 0과 1의 비트 정보를 회선으로 보내기 위한 전기적 신호 변환                    | RS-232C                                  | Bit
</code></pre>
<h2 id="dbms-분석">DBMS 분석</h2>
<ul>
<li>데이터베이스의 가용성, 성능, 기술지원, 호환성, 구축 비용 등을 분석한다.</li>
</ul>
<h3 id="dbms의-기능"><strong>DBMS의 기능</strong></h3>
<pre><code>    기능                                  | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  증복 제어                             | 동일한 데이터가 여러 위치에 중복으로 저장되는 현상을 방지
  접근 통제                             | 권한에 따라 데이터에 대한 접근 제어
  인터페이스 제공                        | 사용자에게 SQL 및 CLI, GUI 등 다양한 인터페이스 제공
  관계 표현                             | 서로 다른 데이터 간의 다양한 관계를 표현할 수 있는 기능 제공
  샤딩/ 파티셔닝                        | 구조 최적화를 위해 작은 단위로 나누는 기능 제공
  무결성 제약조건                       | 무결성에 관한 제약조건을 정의/ 검사하는 기능 제공
  백업 및 회복                          | 데이터베이스 장애 발생 시 데이터의 보존 기능 제공
</code></pre>
<h3 id="dbms의-현행-시스템-분석"><strong>DBMS의 현행 시스템 분석</strong></h3>
<pre><code>  관점              | 고려사항                                          | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  성능 측면         | 가용성                                            | 장기간 시스템을 운영할 때 장애 발생 가능성, 백업 및 복구 편의성
                    | 성능                                           | 대규모 데이터 처리 성능, 대량 거래 처리 성능, 다양한 튜닝 옵션 지원 여부
                    | 상호 호환성                                       | 공급 업체들의 안정적인 기술 지원, 다수의 사용자 간의 정보 공유, 오픈 소스 여부
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  지원 측면          | 기술 지원                                        | 설치 가능한 운영체제의 종류
                    | 구축 비용                                        | 유지 및 관리 비용
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</code></pre>
<h2 id="비즈니스-융합">비즈니스 융합</h2>
<ul>
<li>융합기술이 제공하는 기회나 융합의 언리를 적용해서 새로운 제품, 서비스, 산업을 창울하거나 기존 제품을 혁신하기 위한 기업 활동</li>
</ul>
<h3 id="비즈니스-융합-유형"><strong>비즈니스 융합 유형</strong></h3>
<pre><code>    유형                          | 설명                                                          | 사례
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    고객 가치 (Why)               | 개인, 사회, 인류의 행복과 번영을 위한 가치 창출                   | 신재생 에너지 개발, 친환경 농산물 생산
    시장 유통 (Whom)              | 신시장 개척 또는 미래시장 선점                                   | 자율주행 자동차, 글로벌 통신망
    가치 제안 (What)              | 시장/ 고객의 미 충족 욕구 대응 신상품 개발                        | 드론 배송, 협동 로봇, 소셜 로봇
    공급 역량 (Who)               | 신기술, 신규역량을 활용한 상품생산 및 판매                        | 스마트 밴드, 스마트 헬스케어
    생산 방식 (How)               | 제품/ 서비스의 생산, 판매 프로세스의 혁신                         | 스마트 팩토리, 옴니채널
</code></pre>
<h3 id="비즈니스-융합-분석-절차"><strong>비즈니스 융합 분석 절차</strong></h3>
<pre><code>    기업전략 분석 -&gt; 영역 및 방향 설정 -&gt; 포트폴리오 선정 -&gt; 융합모델 설계/ 평가 -&gt; 비즈니스 융합 실행/ 개선
</code></pre>
<h2 id="요구분석의-개념">요구분석의 개념</h2>
<ul>
<li>
<p>도출된 요구사항 간 상충을 해결하고 소프트웨어의 범위를 파악하여 외부환경과의 <strong>상호작용</strong>을 <strong>분석</strong>하는 과정</p>
</li>
<li>
<p>외부 사용자와 인터페이스 및 내부 시스템 구성요소 간 인터페이스를 정확히 분석해 시스템을 계층적이고 구조적으로 표현한다.</p>
<pre><code> 기법                                  | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 요구사항 분류                          | 요구사항이 기능인지 비기능인지, 소프트웨어에 미치는 영향의 범위를 파악, 소프트웨어 생명주기 동안 변경이 발생하는지를 확인
 개념 모델링                            | 개념 모델은 문제 도메인의 엔터니 (Entity)들과 개별 관계 및 종속성을 반영
 요구사항 할당                          | 요구사항을 만족시키기 위한 아키텍처 구성요스를 식별하는 활동, 추가적인 요구사항 발견 가능
 요구사항 협상                          | 두 명의 이해관계자가 서로 상충되는 내용을 요구하는 경우, 어느 한쪽을 지지하기보다는 적절한 지점에서 합의하기 위한 기법
 정형 분석                              | 형식적으로 정의된 의미를 지닌 언어로 요구사항을 표현, 요구사항 분석의 마지막 단계에서 이루어짐
</code></pre>
</li>
</ul>
<h2 id="uml-unified-modeling-language">UML (Unified Modeling Language)</h2>
<ul>
<li>객체지향 소프트웨어 개발과정에서 산출물을 <strong>명세화, 시각화, 문서화</strong> 할 시 사용되는 모델링 기술과 방법론을 통합해 만든 표준화된 <strong>범용 모델링 언어</strong></li>
</ul>
<h3 id="uml-특징"><strong>UML 특징</strong></h3>
<pre><code>   특징                 | 설명
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   가시화 언어          | 개념 모델 작성 시 오류가 적고 의사소통이 용이
   구축 언어            | 실행 시스템에 대한 시각적 예측 가능
   명세화 언어          | 정확한 모델 제시, 완전한 모델 작성 가능
   문서화 언어          | 시스템에 대한 평가 및 의사소통의 문서
</code></pre>
<h3 id="uml-구성요소"><strong>UML 구성요소</strong></h3>
<pre><code>   구성요소                     | 내용
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   사물 (Things)                | 추상적인 개념으로, 주제를 나타내는 요소, 단어 관점에서 '명사' 또는 '동사'를 의미
   관계 (Relationships)         | 사물의 의미를 확장하고 명확히 하는 요소, 사물과 사물을 연결하여 관계를 표현하는 요소
   다이어그램 (Diagrams)        | 사물과 관계를 모아 그림으로 표현한 형태, 형식과 목적에 따라 9가지로 정의
</code></pre>
<h3 id="uml-다이어그램"><strong>UML 다이어그램</strong></h3>
<pre><code>   구분         | 다이어그램                            | 설명
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   요구사항     | 유스케이스 (Usecase)                  | 사용자 관점에서 시스템의 활동을 표현, 유스케이스는 시스템의 기능적 요구 정의
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   정적 모델링  | 클래스 (Class)                        | 시스템 내 클래스의 정적 구조를 표현, 속성과 동작으로 구성
               | 객체 (Object)                         | 객체 인스턴스를 나타내는 대신 실제 클래스를 사용
               | 상태 (State)                          | 모든 가능한 상태와 전이 표현, 진입 조건, 탈출 조건, 상태 전이 등 기술
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   동적 모델링  | 시퀸스 (Sequence)                     | 객체 간 상호작용을 메시지 흐름으로 표현
               | 협업 (Collaboration)                  | 객체 간 연관성을 표현
               | 활동 (Activity)                       | 활동의 순서대로 흐름을 표현
               | 컴포넌트 (Component)                  | 코드 컴포넌트 기반의 물리적 구조 표현
               | 배포 (Deployment)                     | 컴포넌트 사이의 종속성을 표현
</code></pre>
<h2 id="애자일-agile">애자일 (Agile)</h2>
<ul>
<li>처음부터 끝까지 계획을 수립하고 개발하는 폭포수 (Waterfall)방법론과 달리 <strong>개발과 함께 즉시 피드백을 받아서 유동적으로 개발</strong>하는 방법</li>
<li>소프트웨어 개발 트렌드가 모바일 환경으로 변화, 시장 적시성과 잦은 배포의 중요성이 부각되면서 중요해지기 시작</li>
<li>전통적 방법론은 문서 절차 위주로 변화에 신속한 대응이 어려워, 빠르게 적응하고 효율적으로 개발할 수 있는 방법론의 필요성 대두</li>
</ul>
<h3 id="애자일-선언문"><strong>애자일 선언문</strong></h3>
<ul>
<li>공정과 도구보다 개인과 상호작용</li>
<li>계획을 따르기보다 변화에 대응하기</li>
<li>포괄적인 문서보다 등장하는 소프트웨어</li>
<li>계약 협상보다 고객과의 협력</li>
</ul>
<h3 id="애자일-방법론-유형"><strong>애자일 방법론 유형</strong></h3>
<pre><code>  종류                                                  | 내용
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  XP (eXtreme Programming)                              | 의사소통 개선과 즉각적 피드백으로 소프트웨어 품질을 높이기 위한 방법론 (1~3주의 반복 개발 주기 및 용기, 단순성, 의사소통, 피드백, 존중 5가지 가치)
  스크럼 (SCRUM)                                        | 매일 정해진 시간, 장소에서 짧은 시간에 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론 (백로그, 스프린트, 스크럼 미팅, 스크럼 마스터)
  린 (LEAN)                                             | 도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법론
</code></pre>
<h3 id="애자일과-전통적-방법론-비교"><strong>애자일과 전통적 방법론 비교</strong></h3>
<pre><code>  비교 대상                         | 애자일 방법론                                                         | 전통적 방법론
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  계획 수립                         | 유동적 범위 설정                                                      | 확정적 범위 설정
  업무 수행                         | 팀 중심 업무 수행                                                     | 관리자 주도적 명령과 통제, 개인 단위의 업무 수행
  개발/ 검증                        | 반복 주기 단위로 소프트웨어를 개발/ 검증                                | 분석/ 설계/ 구현/ 테스트를 순차적으로 수행
  팀관리                            | 업무 몰입, 팀 평가                                                    | 경쟁, 개별 평가
  문서화                            | 문서화보다는 코드를 강조                                               | 상세한 문서화를 강조
  성공요소                          | 고객 가치 전달                                                        | 계획/ 일정 준수
</code></pre>
<h2 id="모델링-modeling기법">모델링 (Modeling)기법</h2>
<ul>
<li>실세계의 물리현상을 특정한 목적에 대응하여 이용하기 쉬운 형식으로 표현하는 기법</li>
<li>실세계 문제에 대한 모델링이 소프트 웨어 요구사항 분석의 핵심</li>
</ul>
<h3 id="모델링의-절차"><strong>모델링의 절차</strong></h3>
<pre><code>  요구사항 분석 -&gt; 개념 모델링 -&gt; 논리 모델링 -&gt; 물리 모델링
</code></pre>
<h3 id="분석-자동화-도구"><strong>분석 자동화 도구</strong></h3>
<ul>
<li>
<p>요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 요구사항 분석을 위한 자동화 도구(CASE)</p>
</li>
<li>
<p>분석 자동화 도구는 소프트웨어 위기의 극복 대응방안이 대두되면서 산업적 측면에서의 등장배경을 가지고 있다.</p>
</li>
<li>
<p>분석 자동화 도구는 사용자의 요구사항과 실제 시스템 간의 차이 발생 극복, 시스템의 재사용성과 생산성과 유지보수의 향상 등 관리측면에서의 등장배경을 가지고 있다.</p>
</li>
<li>
<p>표준화 적용과 문서화를 통한 보고를 통해 품질 개선이 가능하며, 변경사항과 변경으로 인한 영향에 대한 추적이 쉽다.</p>
</li>
<li>
<p>명세에 대한 유지보수 비용의 축소가 가능하다.</p>
<pre><code> 분류                                          | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 상위 (Upper) CASE                             | 계획수립, 요구분석, 기본설계 단계를 다이어그램으로 표현
                                              | 모델들 사이의 모순 검사 지원, 모델의 오류 검증 및 자료흐름도 작성 지원
 중간 (Middle) CASE                            | 상세 설계 작업 지원 및 화면 출력 등의 작성 지원
 하위 (Lower) CASE                             | 시스템 명세서 생서어 지원, 소스 코드 생성 지원
</code></pre>
</li>
</ul>
<h3 id="요구사항-관리-도구"><strong>요구사항 관리 도구</strong></h3>
<ul>
<li>
<p>요구사항 관리 도구는 요구사항을 기반으로 하는 프로젝트 관리, 설계, 개발, 테스트 등을 수행할 수 있는 역할을 지원하는 도구이다.</p>
<pre><code> 구분                  |                                                       | 설명
 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 기본기능              | 프로젝트 생성                                              | 프로젝트 타입 및 기본 모듈 템플릿, 프로젝트 생성 및 재사용 가능
                    | 요구사항 작성                                              | 요구사항 별 고유 ID, 식별자 사용 구분
                    | 요구사항 불러내기/ 내보내기                                 | .doc, .xls, .html 등 다양한 확장자 제공
 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 핵심기능              | 요구사항 이력 관리                                         | 요구사항별 변경 이력 관리 기능 제공
                    | 요구사항 베이스 라인                                       | 요구사항 확정을 위한 베이스 라인 제공
                    | 요구사항 추적성                                            | 요구사항 이력 추적 가능
 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 부가기능              | 협업 환경                                                  | 요구사항 산출물의 동시편집 기능 제공
                    | 외부 인터페이스                                             | 형상 관리 도구(SVN, Git)와의 연동 지원
                    | 확장성                                                     | API 등을 통한 타 시스템 연동 제공
</code></pre>
</li>
</ul>
<h3 id="요구사항-관리-도구의-종류"><strong>요구사항 관리 도구의 종류</strong></h3>
<pre><code>    구분                      | 관리 도구                                               | 설명
    -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    상용제품                | 헬릭스 RM(Helix Rm)                                     | 요구사항 추적성 매트릭스 제공, 요구사항의 재사용을 통해 검증 시간과 반복 업무를 줄임
                           | 지라 (Jira)                                             | 애플리케이션 생명주기 관리 (ALM; Application Lifecycle Management)와 요구사항 관리에 사용하는 도구
                           | 오르카노스 (Orcanos)                                     | 기업을 대상으로 요구사항 관리용 단일 저장소 (Repository)를 제공, 임베디드 보고서, 맞춤형 템플릿 지원
                           | 리큐테스트 (ReQtest)                                     | 요구사항을 파악 및 관리하는 프로세스를 단순화, 비즈니스 요구사항은 트리 구조로 저장 
    -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    오픈소스                | 레드마인 (RedMine)                                      | 웹 기반의 프로젝트 관리와 버그 추적 기능을 제공하는 도구, 이소 추적, 형상 관리 기능 제공
                           | 테스트링크 (Testlink)                                    | 테스트 케이스와 요구사항의 매핑 지원
</code></pre>
<h2 id="ui-user-interface">UI (User Interface)</h2>
<ul>
<li>넓은 의미에서 <strong>사용자와 시스템 사이에서 의사소통</strong>할 수 있도록 고안된 물리적, 가상의 매개체</li>
<li>좁은 의미로는 정보 기기나 소프트웨어의 화면 등에서 사람이 접하게 되는 화면을 의미</li>
<li>UI 구동환경은 운영체제 확인, 웹 브라우저 확인, 모니터 해상도 확인, 프레임 세트 확인으로 구분 됨</li>
</ul>
<h3 id="ui-유형"><strong>UI 유형</strong></h3>
<pre><code>   유형                                             | 특징                                                      | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  CLI (Command Line Interface)                      | 정적인 텍스트 기반 인터페이스                               | 명령어를 텍스트로 입력하여 조작하는 사용자 인터페이스
  GUI (Graphical User Interface)                    | 그래픽 반응 기반 인터페이스                                 | 그래픽 환경을 기반으로 한 마우스나 전자펜을 이용하는 사용자 인터페이스
  NUI (Natural User Interface)                      | 직관적 사용자 반응 기반 인터페이스                          | 사용자가 가진 경험을 기반으로 키보드나 마우스 없이 신체 부위를 이용하는 사용자 인터페이스
  OUI (Organic User Interface)                      | 유기적 상호작용 기반 인터페이스                             | 입력장치가 곧 출력장치가 되고, 현실에 존재하는 모든 사물이 입출력장치로 변화 할 수 있는 사용자 인터페이스
</code></pre>
<h3 id="ui-분야"><strong>UI 분야</strong></h3>
<pre><code>  분야                                               | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  물리적 제어 분야                                   | 정보 제공과 기능 전달을 위한 하드웨어 기반
  디자인적 분야                                      | 콘텐츠의 정확하고 상세한 표현과 전체적 구성
  기능적 분야                                        | 사용자의 편의성에 맞춰 쉽고 간편하게 사용 가능
</code></pre>
<h3 id="ui-설계-원칙"><strong>UI 설계 원칙</strong></h3>
<pre><code>  설계 원칙                                         | 설명                                                                            | 부특성
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  직관성 (Intuitiveness)                            | 누구나 쉽게 이해하고, 쉽게 사용할 수 있어야 함                                     | 쉬운 검색, 쉬운 사용성, 일관성
  유효성 (Efficiency)                               | 정확하고 완벽하게 사용자의 목표가 달성될 수 있도록 제작                             | 쉬우누 오류 처리 및 복구
  학습성 (Learnability)                             | 초보와 숙련자 모두가 쉽게 배우고 사용할 수 있게 제작                                | 쉽게 학습, 쉬운 접근, 쉽게 기억
  유연성 (Flexibility)                              | 사용자의 인터랙션을 최대한 포용하고, 실수를 방지할 수 있도록 제작                    | 오류 예방, 실수 포용, 오류 감지
</code></pre>
<h3 id="ui-표준"><strong>UI 표준</strong></h3>
<ul>
<li>
<p>UI 표준은 디자인 철학과 원칙 기반하에 전체 시스템에 공통으로 적용되는 화면 간 이동, 화면 구성 등에 관한 규약</p>
<pre><code> UI 표준 구성                                          | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 전체적인 UX 원칙                                      | 사용자의 관점에서 사용자 업무를 효율적으로 수행할 수 있는 UX 원칙 정의
 정책 및 철학                                          | 조직의 목표나 정체성으르 포함하는 정책 및 철학 설정
 UI 스타일 가이드                                      | UI에 대한 구동 환경 및 레이아웃 등을 정의
 UI 패턴 모델 정의                                     | CRUD 방식을 기반으로 데이터 입력, 출력 패턴 모델 정의
 UI 표준 수립을 위한 조직 구성                          | UI 팀 및 표준 개발 팀을 주축으로 추진 조직 구성
 
 UI 표준 수립 시 고려사항                              | 사용자가 불편해하지 않아야 한다.
                                                   | 많은 업무 케이스를 포함해야 한다.
                                                   | 다양한 상황에 대처할 수 있어야 한다.
                                                   | 표준 적용이 쉽도록 충분한 가이드와 활용 수단 제공이 필요하다.
                                                   | 변화하는 상황에 맞게 빠르게 변경할 수 있는 관리조직 수반이 필요하다.
</code></pre>
<hr>
</li>
</ul>
<h3 id="프레임-세트-적용"><strong>프레임 세트 적용</strong></h3>
<pre><code>  구분          | 프레임 구분                                            | 단일 프레임                                           | 웹 애플리케이션
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  콘텐츠 구성   | 프레임 별 콘텐츠 구성, 메뉴 배너 구성 등의 일괄 적용      | 전체 페이지에서 각 영역 별 콘텐츠를 자유롭게 구성 가능    | 페이지 별 구성 콘텐츠에 구성이 동일한 패턴, 페이지 별로 특화된 배너를 적용하는 경우는 적음
  디자인        | 각 프레임별 이미지 적용, 프레임 내 배경 이미지 적용       | 전체 페이지에 적용되는 이미지 가능                      | 업무 처리가 주목적으로 페이지 전체에 이미지 적용하는 경우는 적음
  속도          | 변경되는 프레임만 새로 로딩됨 (브라우저 속도 향상)        | 페이지 전체가 새로 로딩됨 (브라우저 속도 지연)           | 메뉴 변경시 페이지 로딩이 빨라야 함 
</code></pre>
<h3 id="ui지침-guideline"><strong>UI지침 (Guideline)</strong></h3>
<ul>
<li>
<p>UI표준에 따라 사용자 인터페이스 설계, 개발 시 지켜야할 세부 사항을 규정하는 것을 의미</p>
</li>
<li>
<p>UI지침은 목표 정의, 프로젝트 계획, 요구사항 정의, 설계 및 구현, 테스트, 배포 및 관리의 순서로 이루어진다.</p>
</li>
</ul>
<h3 id="ui-설계-프로세스"><strong>UI 설계 프로세스</strong></h3>
<ul>
<li>UI 설계 프로세스는 문제 정의, 사용자 모델, 작업 분석, 컴퓨터 오브젝트 및 기능 정의, 사용자 인터페이스 정의, 디자인 평가 순으로 이루어진다.</li>
<li>UI 흐름 설계는 화면에 표현되어야 할 기능 작성, 화면의 입력 요소 확인, UI 요구사항을 기반으로 유스케이스 설계, 기능 및 양식 확인 순으로 되어있다.</li>
</ul>
<h2 id="감성공학">감성공학</h2>
<ul>
<li>인간의 감성을 정성적, 정략적으로 측정 및 평가하고, 과학적으로 분석하여 이를 구체적인 제품 설계로 실현해 내는 공학</li>
<li>감성공학의 연구영역은 인간의 생리적, 심리적 특성에 기반한 인간과 기계 또는 인간과 환경 사이를 연계시키는 인터페이스 설계 분야</li>
</ul>
<h3 id="감성공학의-접근-방법"><strong>감성공학의 접근 방법</strong></h3>
<pre><code> ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  구분                    | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  1류 접근 방법            | 의미 미분법 (인간의 감성을 표현하는 어휘를 이용하여 제품 이미지를 조사하고 연계시키는 접근방법)
  2류 접근 방법            | 문화적 감성의 일부 반영 (개인의 연령, 성별 등의 개별적 특성과 생활 방식으로부터 개인이 갖고 있는 이미지를 구체화 시키는 방법으로 감성의 심리적 특성을 강조한 접근 방법)
  3류 접근 방법            | 기존의 감성적 어휘 대신 공학적인 방법으로 접근하여 인간의 감각을 측정 이를 바탕으로 수학적 모델을 구착하여 활용한 방법이다.
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 화면 설계 도구
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  도구                                                      | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  파워 목업 (Power Mockup)                                  | 파워 목업은 파워포인트에 추가 메뉴를 설치해 목업 기능을 사용할 수 있도록 지원하는 툴
  발사믹 목업 (Balsamiq Mockup)                             | 스케치한 느낌으로 빠르고 심플하게 서비스 콘셉트를 전달할 수 있는 목업 도구
  카카오 오븐 (oven)                                        | 카캌오에서 제작한 온라인 프로토타이핑 도구, 직관적인 인터페이스가 장점
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 프로토타이핑 도구
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  도구                         | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  UX (UXpin)                  | 웹 브라우저를 통해 와이어 프레임과 프로토타이핑 작업을 동시에 할 수 있는 도구
  액슈어 (AXURE)               | UI 설계보다는 스토리보드에 포함되는 정책, 플로 차트, 디스크립션까지 모두 작성 가능한 도구
  네이버 프로토나우 (ProtoNOW)  | 네이버에서 만든 프로토타이핑 툴로 스토리보드, 플로 차트 등의 기능 지원 가능 도구
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


#공통모듈설계

 - 전체 프로그램의 기능 중 특정 기능을 처리할 수 있는 실행 코드를 의미
 - 자체적으로 컴파일이 가능하며, 다른 프로그램에서의 재사용이 가능
 - 여러 기능 및 프로그램에서 공통으로 사용할 수 있는 모듈을 의미, 날짜 처리를 위한 유틸리티 모듈 등이 해당

 공통 모듈 원칙
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  원칙                                            | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  정확성 (Correctness)                             | 해당 기능이 실제 시스템 구현 시 필요한지 아닌지를 알 수 있도록 정확하게 작성
  명확성 (Clarity)                                 | 해당 기능에 대해 일관되게 이해되고 한 가지로 해석될 수 있도록 작석
  완전성 (Completeness)                            | 시스템이 구현 될 때 필요하고 요구되는 모든 것을 기술
  일관성 (Consistency)                             | 공통 기능 간에 상호 출돌이 없도록 작성
  추적성 (Traceability)                            | 공통 기능에 대한 요구사항 출처와 관련 시스템 등의 유기적 관계에 대한 식별이 가능하도록 설정
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


#모듈화 (Modularity)

 - 프로그램이 효율적으로 관리될 수 있도록 시스템을 분해하고 추상화함으로써 소프트웨어 제품의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리를 쉽게 하는 기법을 의미
 - 모듈의 크기가 너무 작아 모듈 개수가 많아지면 모듈 간 통합 비용이 많이 발생하며, 크기가 너무 커지면 비용은 줄어들지만 개발 비용이 커진다.

 모듈화 유형
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  유형                                                  | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  응집도                                                | 모듈 내부에서 구성요소 간에 밀접한 관계를 맺고 있는 정도, 응지보가 높을 수록 필요한 요소들로 구성되어 있고 낮을수록 관련이 적은 요소를 나타냄
  결합도                                                | 모듈과 모듈 간에 어느 정도 관련성이 있는지를 나타내는 정도, 관련이 적을수록 모듈의 독립성이 높아 모듈 간 영향이 적어짐
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 응집도 유형
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  유형                                                  | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  우연적 응집도 (Coincidental Cohesion)                  | 모듈 내부의 각 구성요소들이 연관이 없을 경우
  논리적 응집도 (Logical Cohesion)                       | 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우
  시간적 응집도 (Temporal Cohesion)                      | 연관된 기능이라기보다는 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우
  절차적 응집도 (Procedural Cohesion)                    | 모듈의 다수의 관련 기능을 가질 때, 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우
  통신적 응집도 (Communication Cohesion)                 | 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있을 경우
  순차적 응집도 (Sequential Cohesion)                    | 모듈 내에서 한 활동으로부터 나온 출력 값을 다른 활동이 사용할 경우
  기능적 응집도 (Functional Cohesion)                    | 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 결합도 유형
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  유형                                                  | 설명                                                                                                            |  결합도와 품질 0 (낮음) ~ 10 (높음)
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  내용 결합도 (Content Coupling)                         | 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우                                                     |                   0        
  공통 결합도 (Common Coupling)                          | 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호 작용하는 경우                   |                   ~
  외부 결합도 (External Coupling)                        | 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우                             |                   ~
  제어 결합도 (Control Coupling)                         | 단순 처리할 대상인 값만 전달되는 게 아니라 어떻게 처리해야 한다는 제어 요소가 전달되는 경우                           |                   ~
  스탬프 결합도 (Stamp Coupling)                         | 모듈 간의 인터페이스로 배열이나 오브젝트, 스트럭처 등이 전달되는 경우                                                |                   ~  
  자료 결합도 (Data Coupling)                            | 모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 모듈 간의 상호작용이 일어나는 경우                                |                   10
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


#설계모델링

 - 요구하항 분석 단계에서 규명된 필수 기능들의 구체적인 구현 방법을 명시하는 기법
 - 소프트웨어에 요구되는 기능과 성능 조건들을 만족하는 소프트웨어의 내부기능, 구조 및 동적 행위들을 모델링하여 표현, 분석, 검증하는 과정
 - 설계 모델링의 유형에는 시스템의 구성요소들과 이들 사이의 구조적인 관계와 특성을 모델링한 구조 모델링과 어떠한 순서로 수행되는가와 같은 동적인 특성의 행위 모델링이 있음

 소프트웨어 설계 유형
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  설게 유형                                                         | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  자료 구조 설계 (Data Structure Design)                             | 요구 분석 다녜에서 생성된 정보를 바탕으로 소프트웨어를 구현하는 데 필요한 자료 구조로 변환하는 과정
  아키텍처 설계 (Architecture Design)                                | 예비 설계 또는 상위 수준 설계, 소프트웨어 시스템의 전체 구조를 기술, 소프트웨어를 구성하는 컴포넌트 간의 관계를 정의
  인터페이스 설계 (Interface)                                        | 소프트웨어와 상호 작용하는 컴퓨터 시스템, 사용자 등이 어떻게 통신하는지를 기술
  프로시저 설게 (Procedure Design)                                   | 프로그램 아키텍처의 컴포넌트를 소프트웨어 컴포넌트의 프로시저서술로 변환하는 과정
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


#소프트웨어 아키텍처 (Software Architecture)

 - 여러 가지 소프트웨어의 구성요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체를 의미

 소프트웨어 아키텍처 프레임워크 구성요소
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  구성요소                                                | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  아키텍처 명세서                                          | 아키텍처를 기록하기 위한 산출물들, 이해관계자들의 시스템에 대한 관심을 관점에 맞추어 작성한 뷰로 표현
  이해관계자                                               | 시스템 개발에 관련된 모든 사람과 조직, 고객, 최종사용자, 개발자, 프로젝트 관리자, 유지보수자 등
  관심사                                                  | 시스템에 대해 이해관계자들의 서로 다른 의견과 목표 (사용자 입장, 유지보수자 입장, 개발자 입장)
  관점                                                    | 개별 뷰를 개발할 때 토대가 되는 패턴이나 양식, 이해관계자들이 서로 다른 역할이나 책임으로 시스템이나 산출물들에 대해 보고 싶은 관점
  뷰                                                      | 서로 관련 있는 관심사들의 집합이라는 관점에서 전체 시스템을 표현
  근거                                                    | 아키텍처 결정 근거, 회의 결과, 보고 결과
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 

 소프트웨어 아키텍처 4+1 뷰
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
  뷰                                                      | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
  유스케이스 뷰 (Use-Case View)                            | 유스케이스는 아키텍처를 도출하고 설계하는 작업을 주도, 아키텍처의 다른 뷰를 검증하는 데 사용
  논리 뷰 (Logical View)                                  | 시스템의 기능적인 요구사항 지원, 설계 모델의 추상화이며, 주요 설계 패키지의 서브 시스템, 클래스를 식별
  프로세스 뷰 (Process View)                               | 런타임 시의 시스템의 태스크 (Task), 스레드 (Thread), 프로세스(Process)와 이들 사이의 상호작용 등의 관계를 표현
  구현 뷰 (Implementaion View)                             | 개발 환경 안에서 정적인 소프트웨어 모듈 (소스 코드, 데이터 파일, 컴포넌트, 실행 파일 등)의 구성 표현, 컴포넌트 다이어그램으로 표현, 컴포넌트 뷰라고도 함
  배포 뷰 (Deployment View)                                | 다양한 실행 파일과 다른 런타임 컴포넌트가 해당 플랫폼 또는 컴퓨팅 노드에 어떻게 매핑되는가를 보여주며, 가용성, 신뢰성, 성능, 확장성 등의 시스템의 비기능적인 요구사항으 고려
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 

 소프트웨어 아키텍처 비용 평가 모델 종류
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
  종류                                                       | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
  SAAM (Software Architecture Analysys Method)              | 변경 용이성과 기능성에 집중, 평가가 용이하여 경험이 없는 조직에서도 활용 가능
  ATAM (Architecture Trade-off Analysys Method)             | 아키텍처 품질 속성을 만족시키는지 판단 및 품질 속성들의 상충관계까지 평가
  CBAM (Cost Benefit Analysis Methood)                      | 경제적 의사결정에 대한 요구를 충족, ATAM 바탕의 시스템 아키텍처 분석 중심, 경제적 모델링 방법
  ADR (Active Design Review)                                | 소프트웨어 아키텍처 구성요소 간 응집도 평가
  ARID (Active Reviews for Intermediate Designs)            | 전체 아키텍처가 아닌 특정 부분에 대한 품질요소에 집중                        
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 


#객체지향 (Object Oriented)

 = 실세계의 개체를 속성과 매서드가 결합한 형태의 객체로 표현하는 개념

 객체지향 구성요소
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  구성요소                                                   | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  클래스 (Class)                                             | 같은 종류의 집단에 속하는 속성과 행위, 속성은 변수의 형태로, 행위는 매서드 형태로 선언, 객체지향 프로그램의 기번족인 사용자 정의 데이터형
  객체 (Object)                                              | 객체의 행위는 클래스에 정의된 행위에 대한 정의를 공유함으로써 메모리를 경제적으로 사용
  메서드 (Method)                                            | 클래스로부터 생성된 객체를 사용하는 방법, 전통적 시스템의 함수(Function) 또는 프로시저(Procedure)에 해당하는 연산기능
  메시지 (Message)                                           | 객체에게 어떤 행위를 하도록 지시하기 위한 방법
  인스턴스 (Instance)                                        | 객체지향 기법에서 클래스에 속한 각각의 객체, 실제로 메모리상에 할당
  속성 (Property)                                            | 한 클래스 내에 속한 객체들이 가지고 있는 데이터 값들을 단위별로 정의
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 객체지향 기법
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  기법                                                      | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  캡슐화                                                    | 서로 관련성이 많은 데이터와 이와 관련된 함수들을 한 묶음으로 처리하는 기법, 결합도가 낮아지고 재사용에 용이
  상속성                                                    | 상위 클래스의 속성과 메소드를 하위 클래스에서 재정의 없이 물려받아 사용하는 기법
  다형성                                                    | 하나의 메시지에 대해 각 객체가 가지고 있는 고유한 방법으로 응답하라 수 있는 능력, 오버로딩, 오버라이딩이 대표적
  추상화                                                    | 공통 성질을 추출하여 추상 클래스를 설정하는 기법, 기능 추상화, 자료 추상화, 제어 추상화가 있음
  정보은닉                                                  | 코드 내부 데이터와 메소드를 숨기고 공개 인터페이스를 통해서만 접근이 가능하도록 하는 코드 보안 기술
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  객체지향 설계 원칙(SOLID)
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  원칙                                                      | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  단일 책임의 원칙 (Single Responsibility Principle)         | 하나의 클래스는 하나의 목적을 위해서 생성되며, 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어 있어야 한다는 원칙
  개방 폐쇄 원칙 (Opne Close Principle)                      | 소프트웨어의 구성요소 (컴포넌트, 클래스, 모듈, 함수)는 확정에는 열려 있고, 변경에는 닫혀있어야 한다는 원칙
  리스코프 치환의 원칙 (Liskov Substitution)                 | 자식 클래스 (서브 타입)은 언제나 자신의 부모 클래스 (기반 타입)을 대체한다는 원칙
  인터페이스 분리의 원칙 (Interface Segregation Principle)    | 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙
  의존성 역전의 원칙 (Dependency Inversion Principle)        | 실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고받음으로써 관계를 최대한 느슨하게 만드는 원칙
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 객체지향 방법론의 종류
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  종류                                               | 설명                                                                     | 특징
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  OOSE (Object Oriented Software Engineering)       | 유스케이스에 의한 접근 방법으로 유스케이스를 모든 모델의 근간으로 활용         | 분석, 설계, 구현 단계로 구성 (기능적 요구사항 중심의 시스템)
  OMT (Object Modeling Technology)                  | 객체지향 분석, 시스템 설계, 오브젝트 설계 및 구현의 4단계로 구성              | 복잡한 대형 프로젝트에 유용
  Booch (OOD: Object Oriented Design)               | 설계부분만이 존재하며, 설계 문서화를 강조하여 다이어그램 중심으로 개발         | 분석과 설계 분리 불가능, 분석하는 데 이용된 객체 모델의 설계시 적용
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
 
#디자인패턴 (Design Pattern)

 - 어떤 분야에서 반복적으로 나타나는 문제점들에 대해 전문가들의 경험을 정리하여 해결 방안을 제시한 패턴
 - 디자인 패턴을 참고하여 개발할 경우 개발의 효율성과 유지 보수성, 운용성 등의 품질이 높아지며, 프로그램의 최적화에 도움이 된다.

 디자인 패턴 구성요소
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  구성요소                                    | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  패턴 이름                                   | 설계 의도를 표현할 수 있도록 문제와 해법을 설명
  문제                                        | 해결하고자 하는 문제와 배경, 패턴 사용 시점을 서술
  해법                                        | 패턴을 구성하는 요소, 요소 간의 관계, 책임, 상호관계를 서술
  결과                                        | 패턴을 적용해서 얻은 결과와 장단점을 서술
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------4

 디자인 패턴 유형
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  구분                | 유형                   | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  목적                | 생성                   | 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴
                      | 구조                   | 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
                      | 행위                   | 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  범위                | 클래스                 | 클래스 간 관련성, 즉 상속 관계를 다루는 패턴 (컴파일 타임에 정적으로 결정)
                      | 객체                   | 객체 간 관련성을 다루는 패턴 (런타임 동적으로 결정)
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\


#내, 외부 인터페이스 요구사항

 - 내, 외부 인터페이스란 조직 내, 외부에 존재하는 시스템이 연동을 통해 상호 작용하기 위한 접속 방법이나 규칙을 의미
 - 내, 외부 인터페이스 요구사항이란 조직 내, 외부에 존재하는 시스템들이 상호 접속을 통하여 특정 기능을 수행하기 위한 접속 방법이나 규칙에 대한 필수적 요구사항
 - 내, 외부 인터페이스 요구사항을 위해서는 구성요소들 간의 사전에 연동 방안에 대한 협의가 필요하다.
 - 내, 외부 인터페이스의 요구사항에는 수행될 기능과 관련되어야 하는 기능적 요구사항과 연계시 용이성, 신뢰도, 보안성 등 시스템 전반과 관련된 요구사항인 비기능적 요구사항이 있다.

 내, 외부 인터페이스 관련 요구사항 식별 및 분류 방안
  요구사항 식별 -&gt; 명세서 및 현황 자료 준비 -&gt; 기능 요구사항 및 비기능 요구사항 분류

 내, 외부 인터페이스 요구사항 명세서 구체화 프로세스
  내, 외부 인터페이스 요구사항 정의서 세분화 -&gt; 내, 외부 인터페이스 요구사항 내용의 이해 및 수정 -&gt; 누락된 내, 외부 인터페이스 요구사항 신규 정의 -&gt; 내 외부 인터페이스 요구 사항 정리
 

#요구공학 (Requirements Engineering)

 - 요구공학은 사용자의 요구가 반영된 시스템을 개발하기 위하여 사용자 요구사항에 대한 추출, 분석, 명세, 검증, 관리하는 구조화된 활동
 - 이해관계자 사이에 효과적인 의사소통 수단을 제공 및 시스템 개발의 요구사항에 대한 공통된 이해를 설정
 - 요구사항 누락 방지 및 이해 오류로 인한 불필요한 비용을 절감하고 요구사항 변경 추적을 가능하게 한다.
 - 요구공학의 기본은 시스템의 요구사항에 대한 파악
 -
 요구사항의 분류
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  구분                  | 기능적 요구 사항                                                          | 비기능적 요구사항
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  개념                  | 시스템이 제공하는 기능, 서비스에 대한 요구 사항                               | 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항에 관한 요구사항
  도출 방법              | 특정 입력에 대해 시스템이 어떻게 반응해야 하는지에 대한 기술                   | 품질 속성에 관련하여 시스템이 갖춰야 할 사항에 관한 기술
  특성                  | 기능성, 완전성, 일관성                                                     | 신뢰성, 사용성, 효율성, 유지 보수성, 이식성
  사례                  | 온라인 홈페이지에서는 쇼핑카트에 주문하고자 하는 품목을 저장할 수 있는 장바구니   | 특정 함수의 호출시간은 3초를 넘지 않아야 하며, 시스템은 하루 24시간 가동되어야 함
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 요구공학 프로세스

  - 요구공학 프로세스는 개발 단계와 요구사항 관리 단계로 구성된다.

 요구사항 개발 단계
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  프로세스                              | 내용                                                                                           | 기법/ 산춘물
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  요구사항 추출                          | 고객으로부터 제시되는 추상적 요구에 대해 관련 정보를 식별&amp; 수집하여 요구사항으로 표현하는 활동          | 인터뷰, 브레인스토밍, 델 파이 기법
  요구사항 분석                          | 추출된 요구사항에 대해 충돌, 중복, 누락 등의 분석을 통해 완정성과 일관성을 확보하는 활동               | 유스케이스 기반 분석 (UML, 모델링)
  요구사항 명세                          | 동의한 요구사항을 하나 이상의 형태로 저장하여 정형화된 요구사항을 생성하는 활동                        | 요구사항 명세서를
  요구사항 검증                          | 요구사항 명세서에 사용자의 요구가 올바르게 기술되었는지에 대해 검토하고 베이스라인으로 설정하는 활동     | 베이스라인 수립, 요구사항 추적표
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 요구사항 개발 단계의 주요 기법
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  주요 기법                                    | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  인터뷰 (Interview)                           | 이해관계자와 직접 대화를 통해 정보를 구하는 공식적, 비공식적 정부 수집 방법
  델파이 기법 (Delphi Method)                  | 전문가의 경험적 지식을 통한 문제 해결 및 미래예측을 위한 기법
  롤 플레이 (Role Playing)                     | 현실에 일어나는 장면을 설정하고, 여러 사람이 각자가 맡은 역을 연기하여 요구사항을 분석하여 수집하는 방법
  UML (Unified Modeling Language)             | 객체지향 소프트웨어 개발과정에서 산출물을 명세화, 시각화, 문서화 할 시 사용되는 모델링 기술과 방법론을 통합해 만든 표준화된 범용 모델링 언어
  모델링 (Modeling)                            | 실세계의 물리현상을 특정한 목적에 대응하여 이용하기 쉬운 형식으로 표현하는 기법을 의미
  요구사항 명세서 (Requirements Specification)  | 소프트웨어 개발 프로세스의 시작인 소프트웨어의 요구사항을 분석하고 정의하는 단계에서 작성되는 최종 산출물
  베이스 라인 (Baseline)                        | 생명주기 내에서 공학적, 관리적, 획득적 측면을 고려하여 정한 하나의 분기점
  요구사항 추적표                               | 요구사항 정의서를 기준으로 개발단계별 최종 산출물이 어떻게 반영되고, 변경되었는 지 확인이 가능한 문서
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  요구사항 명세 원리 및 검증 항목
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  항목          | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  명확성        | 각각의 요구사항 명세 내용은 하나의 의미만 부여해야 함
  완전성        | 기능, 성능, 속성, 인터페이스, 설계 제약 등에 관한 모든 시스템 요구사항이 포함되어야 함
  검증 가능성    | 요구사항 내용의 충족 여부와 달성 정도에 대한 확인이 가능해야 함
  일관성        | 요구사항의 내용 간 상호 모순이 없어야 함
  수정 용이성    | 요구사항 변경 시 쉽게 수정 가능해야 함
  추적 가능성    | 각 요구사항 근거에 대한 추적과 상호참조가 가능해야 함
  개발 후 이용성 | 시스템 개발 후 운영 및 유지보수에 효과적인 이용이 가능해야 함
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 요구사항 관리 프로세스
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  순서    | 프로세스                            | 내용                                                                         | 기법/ 산출물
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  1      | 요구사항 협상                        | 가용한 자원과 수용 가능한 위험 수준에서 구현 가능한 기능을 협상하기 위한 기법       | 우선순위 설정, 시뮬레이션
  2      | 요구사항 기준선                      | 공식적으로 검토되고 합의된 요구사항 명세서                                       | 공식 회의, 형상 관리
  3      | 요구사항 변경관리                    | 요구사항 기준선을 기반으로 모든 변경을 공식적으로 통제하기 위한 기법                | 형상통제 위원회, 영향도 분석
  4      | 요구사항 확인 및 검증                | 구축된 시스템이 이해관계자가 기대한 요구사항에 부합하는 지 확인하기 위한 방법        | 확인 및 검증
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 요구사항 검증 절차
 ------------ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  순서            | 프로세스                            | 내용
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  1              | 요구사항 검토, 계획 수립              | 품질 관리자 또는 프로젝트 관리자가 요구사항 검토기준과 검토방법, 검토 일정과 참여자 등을 포함한 요구사항 검토 계획 수립
  2              | 요구사항 명세서, 검토 및 오류 수정     | 요구사항 검토 계획 수립 시 선저한 검토 방법과 검토 기준에 따라 요구사항 명세서 검토
  3              | 요구사항 베이스라인 설정              | 요구사항 검토를 통해 검증된 요구사항을 공식적으로 승인하고 소프트웨어 설계와 구현을 할 수 있도록 요구사항 명세서의 베이스 라인을 결정
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


#시스템 아키텍처 (System Architecture)

 - 시스템 아키텍처는 시스템의 구조, 행위, 동작 원리를 설명하는 프레임워크이다
 - 시스템 아키텍처는 시스템 목적을 달성하기 위해서 시스템 각 컴포넌트가 무엇이며 어떻게 상호작용하는지, 정보가 어떻게 교환되는지를 설명한다.

 시스템 아키텍처 설계 시 중점 고려사항
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  고려사항                                | 내용
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  기술적 제약사항                          | 계획된/ 계획되지 않은 중단시간 최소화 설계
                                         | 중단 없는 운영 확보를 통한 가용성 확보
                                         | DB 서버의 부하를 최대한 경감하는 방안 고려
                                         | 수직 확장성이 높은 하드웨어 또는 분산 DB 고려
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  기술 요구사항                            | UI 개발 도구는
                                         | 미들웨어 기반 기술에 적합한 아키텍처 설계
                                         | 개발 프레임워크 도입에 따른 개발 및 인터페이스 방식 검토
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  기존 운영상의 문제점 개선                | 장애 발생을 감안한 용량 산정
                                        | 데이터 손실 없이 신속히 서비스를 복구할 수 있는 아키텍처 설계
                                        | 트랜잭션 부하 폭증에 대한 대처 방안 수립
                                        | 대용량 트랜잭션 및 스토리지 운영 관리에 적합한 서버, 스토리지 물리 설계                                                                                          
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


 시스템 아키텍처 설계 원칙
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  설계 원칙                                               | 아키텍처 설계 방안
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  대규모 트랜잭션 처리 및 온라인 성능 보장                   | 피크타임 용량 확보, 대용량 배치 처리, 부하 분산 최적화, DB 용량 경량화
  시스템 아키텍처 확장성 보장                               | 다계층 아키텍처 구성, 하드웨어 확장성, 아키텍처 확장성
  서비스 고가용성 보장                                     | 장애 예방, 서비스 중단시간 최소화, 비상 시스템 구성
  운영관리 효율성                                         | 트랜잭션 관리, 성능 및 장애 관리, 통합 백업 관리
  시스템 보안 강화                                        | 정보 보호 전략 수립, 네트워크 보안, 시스템 보안
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 시스템 아키텍처 물리 설계
 1-Tier (비즈니스 로직 + 데이터)
 2-Tier (UI + 비즈니스 로직, 데이터)
 3-Tier (UI로직, 비즈니스 로직, 데이터)


#인터페이스 시스템 개념

 - 인터페이스 시스템은 서로 다른 두 시스템, 장치, 소프트웨어를 서로 이어주는 접속 및 중계 시스템
 - 인터페이스 시스템은 송신 시스템과 수신 시스템으로 구성할 수 있으며, 연계 방식에 따라 중계 서버를 둘 수 있음

 인터페이스 시스테 구성
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  구성                                              | 내용
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  송신 시스템                                        | 연계할 데이터를 데이터베이스와 애플리케이션으로부터 연계 테이블 또는 파일 형태로 생성하여 송신하는 시스템
  수신 시스템                                        | 수신한 연계 테이블 또는 파일의 데이터를 수신 시스템에서 관리하느느 데이터 형식에 맞게 변환하여 데이터베이스에 저장하거나 애플리케이션에서 활용할 수 있게 하는 시스템
  중계 서버                                          | 송신 시스템과 수신 시스템 사이에서 데이터를 송수신하고, 연계 데이터의 송수신 현황을 모니터링하는 시스템
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
 
#내, 외부/ 송, 수신 

 - 내, 외부/ 송, 수신을 위해서 연계 방식과 연계 기술, 통신 유형의 선택은 성능을 위한 가장 중요한 요소이다.
 - 내, 외부 송, 수신의 연계방식은 직접 연계 방식과 간접 연계 방식으로 분류할 수 있다.

 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  연계 방식             | 장, 단점                | 설명
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  직접 연계 방식        | 장점                    | 중간 매개체가 없어 연계 처리 속도가 빠르고 구현이 단순, 개발 비용과 기간이 짧음
                      | 단점                    | 송신 시스템과 수신 시스템 간의 결합도가 높아서 시스템 변경 시 민감
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  간접 연계 방식        | 장점                    | 송, 수신 처리 및 현황을 모니터링하고 통제하는 연계 서버를 활용하는 방식
                                                | 서로 다른 네트워크와 프로토콜 등 다양한 환경을 갖는 시스템들을 연계하고 통합 관리할 수 있음
                      | 단점                     | 인터페이스 아키텍처와 연계 절차가 복잡하고 연계 서버로 인한 성능저하 및 개발 및 테스트 기간이 오래걸림
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


#데이터 명세화

 - 인터페이스 요구사항 분석 과정에서 식별한 연계 정보 그룹에 해당하는 테이블 정의서, 파일 레이아웃, 코드 정의서 등을 분석하여 필요한 데이터 명세를 만드는 작업
 - 인터페이스 요구사항 분석 과정에서 식별한 개체 정의서, 테이블 정의서, 코드 정의서를 분석하여 필요한 정보를 파악한다.

 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  항목                      | 항목 정의 및 작성 지침
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  논리 DB 명                | 엔터티가 설계된 논리 데이터베이스의 명칭
  엔터티 명                 | 엔터티의 이름으로 '표준용어 정의서'에 등록된 용어를 사용하여 한글로 기재
  엔터니 설명               | 관련된 업무에 대한 개략적인 설명 및 업무 규칙을 기술
  주 식별자                 | 엔터티에서 집합의 유일성을 나타내는 속성 또는 속성의 그룹
  슈퍼타입 엔터티 명         | 해당 엔터티가 슈퍼-서브 타입 관계에 있는 서브 타입 엔터티인 경우에 한하여 상위에 존재하는 슈퍼타입 엔터티의 이름을 기재
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</code></pre>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#플랫폼--platform-">플랫폼 ( Platform )</a>
      <ul>
        <li><a href="#플랫폼의-유형"><strong>플랫폼의 유형</strong></a></li>
        <li><a href="#플랫폼의-기능-분석"><strong>플랫폼의 기능 분석</strong></a></li>
        <li><a href="#플랫폼-기능-분석-절차"><strong>플랫폼 기능 분석 절차</strong></a></li>
        <li><a href="#플랫폼-기능-분석-기법"><strong>플랫폼 기능 분석 기법</strong></a></li>
      </ul>
    </li>
    <li><a href="#운영체제-operating-system-분석">운영체제 (Operating System) 분석</a>
      <ul>
        <li><a href="#운영체제의-현행-시스템-분석"><strong>운영체제의 현행 시스템 분석</strong></a></li>
        <li><a href="#운영체제의-종류-및-특성"><strong>운영체제의 종류 및 특성</strong></a></li>
      </ul>
    </li>
    <li><a href="#네트워크-분석">네트워크 분석</a>
      <ul>
        <li><a href="#osi-7계층"><strong>OSI 7계층</strong></a></li>
      </ul>
    </li>
    <li><a href="#dbms-분석">DBMS 분석</a>
      <ul>
        <li><a href="#dbms의-기능"><strong>DBMS의 기능</strong></a></li>
        <li><a href="#dbms의-현행-시스템-분석"><strong>DBMS의 현행 시스템 분석</strong></a></li>
      </ul>
    </li>
    <li><a href="#비즈니스-융합">비즈니스 융합</a>
      <ul>
        <li><a href="#비즈니스-융합-유형"><strong>비즈니스 융합 유형</strong></a></li>
        <li><a href="#비즈니스-융합-분석-절차"><strong>비즈니스 융합 분석 절차</strong></a></li>
      </ul>
    </li>
    <li><a href="#요구분석의-개념">요구분석의 개념</a></li>
    <li><a href="#uml-unified-modeling-language">UML (Unified Modeling Language)</a>
      <ul>
        <li><a href="#uml-특징"><strong>UML 특징</strong></a></li>
        <li><a href="#uml-구성요소"><strong>UML 구성요소</strong></a></li>
        <li><a href="#uml-다이어그램"><strong>UML 다이어그램</strong></a></li>
      </ul>
    </li>
    <li><a href="#애자일-agile">애자일 (Agile)</a>
      <ul>
        <li><a href="#애자일-선언문"><strong>애자일 선언문</strong></a></li>
        <li><a href="#애자일-방법론-유형"><strong>애자일 방법론 유형</strong></a></li>
        <li><a href="#애자일과-전통적-방법론-비교"><strong>애자일과 전통적 방법론 비교</strong></a></li>
      </ul>
    </li>
    <li><a href="#모델링-modeling기법">모델링 (Modeling)기법</a>
      <ul>
        <li><a href="#모델링의-절차"><strong>모델링의 절차</strong></a></li>
        <li><a href="#분석-자동화-도구"><strong>분석 자동화 도구</strong></a></li>
        <li><a href="#요구사항-관리-도구"><strong>요구사항 관리 도구</strong></a></li>
        <li><a href="#요구사항-관리-도구의-종류"><strong>요구사항 관리 도구의 종류</strong></a></li>
      </ul>
    </li>
    <li><a href="#ui-user-interface">UI (User Interface)</a>
      <ul>
        <li><a href="#ui-유형"><strong>UI 유형</strong></a></li>
        <li><a href="#ui-분야"><strong>UI 분야</strong></a></li>
        <li><a href="#ui-설계-원칙"><strong>UI 설계 원칙</strong></a></li>
        <li><a href="#ui-표준"><strong>UI 표준</strong></a></li>
        <li><a href="#프레임-세트-적용"><strong>프레임 세트 적용</strong></a></li>
        <li><a href="#ui지침-guideline"><strong>UI지침 (Guideline)</strong></a></li>
        <li><a href="#ui-설계-프로세스"><strong>UI 설계 프로세스</strong></a></li>
      </ul>
    </li>
    <li><a href="#감성공학">감성공학</a>
      <ul>
        <li><a href="#감성공학의-접근-방법"><strong>감성공학의 접근 방법</strong></a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>















