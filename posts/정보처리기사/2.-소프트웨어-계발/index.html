<!DOCTYPE html>
<html lang="en">

<head>
  <script data-ad-client="ca-pub-1022327295984162" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="데이터 입출력 구현  자료 구조 ( Data Structure )    컴퓨터상 자료를 효율적으로 저장하기 위해 만들어진 논리적인 구조
  자료 구조의 현명한 선택을 통해 효율적인 알고리즘을 사용할 수 있어 성능을 향샹
   자료 구조의 분류    자료 구조의 분류는 선형 구조와 비선형 구조로 크게 나뉜다
  선형 구조에는 배열, 연결 리스트, 스택, 큐 등이 있다
  비선형 구조엔느 트리, 그래프 등이 존재"><meta property="og:title" content="" />
<meta property="og:description" content="데이터 입출력 구현  자료 구조 ( Data Structure )    컴퓨터상 자료를 효율적으로 저장하기 위해 만들어진 논리적인 구조
  자료 구조의 현명한 선택을 통해 효율적인 알고리즘을 사용할 수 있어 성능을 향샹
   자료 구조의 분류    자료 구조의 분류는 선형 구조와 비선형 구조로 크게 나뉜다
  선형 구조에는 배열, 연결 리스트, 스택, 큐 등이 있다
  비선형 구조엔느 트리, 그래프 등이 존재" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mung0001.github.io/posts/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B3%84%EB%B0%9C/" />


<title>뭉게뭉게</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.63eb88daa545365405ecdbb21033286a325c60a36cfa6d22d21e7c3bc9286941.css" integrity="sha256-Y&#43;uI2qVFNlQF7NuyEDMoajJcYKNs&#43;m0i0h58O8koaUE=">
<script defer src="/en.search.min.cfe4bb8da863b9ae8e25ea2f3bbc3374a424c98ca1602a082c0f11d28c0bd007.js" integrity="sha256-z&#43;S7jahjua6OJeovO7wzdKQkyYyhYCoILA8R0owL0Ac="></script>
<!--

-->

  
</head>

<body>
  <div class="background">
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex" style="max-width:95%;" >
    <aside class="book-menu">
      
  
<nav styles="background-color:red; position=none;">
<div style="font-weight: bolder;"><h2 class="book-brand">
  <a href="/"><span>뭉게뭉게</span>
  </a>
</h2>
</div>
<img style="padding-right: 3%;"src = "https://github.com/mung0001/source/blob/master/static/Go/Golang.jpg?raw=true" width="100%" height="20%" align="center"  >
<div style="padding-top: 0.2cm; font-size: 1.1em; font-weight: bolder;">
  <div style ="padding-bottom: 0.2cm;">
    Jengkeun Lee
  </div>
  <div style ="padding-bottom: 0.2cm;">
    mung0001@naver.com
  </div>
  <div style ="padding-bottom: 0.2cm;">
    내 직업도 뭉게뭉게
  </div>
</div>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  

  
  





 
  
    




  
  <ul>
    
      
        

  <li class="book-section-flat" >
    

  
  <a href="/docs/cloudcomputing/" class="">Cloud Computing</a>
  


    




  
  <ul>
    
      
        

  <li>
    

  
  <a href="/docs/cloudcomputing/amazonwebservice/" class="collapsed ">Amazon Web Service</a>
  


    






  </li>


      
    
      
        

  <li>
    

  
  <a href="/docs/cloudcomputing/awstraining/" class="collapsed ">AWS Training</a>
  


    






  </li>


      
    
      
        

  <li>
    

  
  <a href="/docs/cloudcomputing/openstack/" class="collapsed ">Open Stack</a>
  


    






  </li>


      
    
  </ul>
  



  </li>


      
    
      
        

  <li class="book-section-flat" >
    

  
  <a href="/docs/programing/" class="">Programing</a>
  


    




  
  <ul>
    
      
        

  <li>
    

  
  <a href="/docs/programing/python/" class="collapsed ">Python</a>
  


    






  </li>


      
    
      
        

  <li>
    

  
  <a href="/docs/programing/java/" class="collapsed ">JAVA</a>
  


    






  </li>


      
    
      
        

  <li>
    

  
  <a href="/docs/programing/php/" class="collapsed ">PHP</a>
  


    






  </li>


      
    
      
        

  <li>
    

  
  <a href="/docs/programing/django/" class="collapsed ">Django</a>
  


    






  </li>


      
    
      
        

  <li>
    

  
  <a href="/docs/programing/golang/" class="collapsed ">Golang</a>
  


    






  </li>


      
    
      
        

  <li>
    

  
  <a href="/docs/programing/web/" class="collapsed ">Web</a>
  


    






  </li>


      
    
      
        <li>

  
  <a href="/docs/programing/bigdata/" class="">Bigdata</a>
  

</li>
      
    
      
        <li>

  
  <a href="/docs/programing/git/" class="">Git</a>
  

</li>
      
    
      
        <li>

  
  <a href="/docs/programing/hugo/" class="">Hugo</a>
  

</li>
      
    
  </ul>
  



  </li>


      
    
      
        

  <li class="book-section-flat" >
    

  
  <a href="/docs/network/" class="">Network</a>
  


    




  
  <ul>
    
      
        <li>

  
  <a href="/docs/network/gns3/" class="">G N S3</a>
  

</li>
      
    
      
        <li>

  
  <a href="/docs/network/nas/" class="">Nas</a>
  

</li>
      
    
      
        <li>

  
  <a href="/docs/network/%EC%A0%95%EB%A6%AC/" class="">Home</a>
  

</li>
      
    
      
        <li>

  
  <a href="/docs/network/3tier/" class="">3 Tier</a>
  

</li>
      
    
      
        <li>

  
  <a href="/docs/network/sdn/" class="">S D N</a>
  

</li>
      
    
      
        <li>

  
  <a href="/docs/network/%E3%84%B4-packet/" class="">ㄴ Packet</a>
  

</li>
      
    
      
        <li>

  
  <a href="/docs/network/%E3%84%B4-portnumber/" class="">ㄴ Portnumber</a>
  

</li>
      
    
      
        <li>

  
  <a href="/docs/network/%EB%B0%A9%ED%99%94%EB%B2%BD/" class="">방화벽</a>
  

</li>
      
    
      
        <li>

  
  <a href="/docs/network/%EB%B3%B4%EC%95%88/" class="">보안</a>
  

</li>
      
    
      
        <li>

  
  <a href="/docs/network/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%86%B5%ED%95%A9/" class="">시스템통합</a>
  

</li>
      
    
  </ul>
  



  </li>


      
    
      
        

  <li class="book-section-flat" >
    

  
  <a href="/docs/system/" class="">System</a>
  


    




  
  <ul>
    
      
        <li>

  
  <a href="/docs/system/mail-server/" class="">Mail Server</a>
  

</li>
      
    
      
        <li>

  
  <a href="/docs/system/mount/" class="">Mount</a>
  

</li>
      
    
      
        <li>

  
  <a href="/docs/system/code/" class="">Code</a>
  

</li>
      
    
      
        <li>

  
  <a href="/docs/system/linux/" class="">Linux</a>
  

</li>
      
    
      
        <li>

  
  <a href="/docs/system/%E3%84%B4%EB%B0%A9%ED%99%94%EB%B2%BD/" class="">ㄴ방화벽</a>
  

</li>
      
    
      
        <li>

  
  <a href="/docs/system/%E3%84%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%86%B5%ED%95%A9/" class="">ㄴ시스템통합</a>
  

</li>
      
    
  </ul>
  



  </li>


      
    
      
        

  <li class="book-section-flat" >
    

  
  <span>Project</span>
  


    




  
  <ul>
    
      
        

  <li>
    

  
  <a href="/docs/project/mini/" class="collapsed ">M Ini</a>
  


    






  </li>


      
    
  </ul>
  



  </li>


      
    
  </ul>
  



  














  
<ul>
  
  <li>
    <a href="/posts/" >
        Blog
      </a>
  </li>
  
</ul>







</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>2. 소프트웨어 계발</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#데이터-입출력-구현"><strong>데이터 입출력 구현</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#자료-구조--data-structure-"><strong>자료 구조 ( Data Structure )</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#자료-구조의-분류"><strong>자료 구조의 분류</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#리스트의-종류"><strong>리스트의 종류</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#스택--stack-"><strong>스택 ( Stack )</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#큐--queue-"><strong>큐 ( Queue )</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#데크--deque-double-ended-queue-"><strong>데크 ( Deque: Double Ended Queue )</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#트리-tree"><strong>트리 Tree</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#트리-순회-방법"><strong>트리 순회 방법</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#이진-트리"><strong>이진 트리</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#그래프--graph-"><strong>그래프 ( Graph )</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#논리-데이터-저장소"><strong>논리 데이터 저장소</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#논리-데이터-저장소-검증-절차"><strong>논리 데이터 저장소 검증 절차</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#물리-데이터-저장소"><strong>물리 데이터 저장소</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#물리-데이터-저장소-모델-변환-절차"><strong>물리 데이터 저장소 모델 변환 절차</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#물리-데이터-저장소-구성"><strong>물리 데이터 저장소 구성</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#테이블-제약조건--constraint-설계"><strong>테이블 제약조건 ( Constraint )설계</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#인덱스--index--설계"><strong>인덱스 ( Index ) 설계</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#뷰-view--설계"><strong>뷰( View ) 설계</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#클러스터-cluster--설계"><strong>클러스터( Cluster ) 설계</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#파티션-partition--설계"><strong>파티션( Partition ) 설계</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#디스크-disk-구성-설계"><strong>디스크( Disk )구성 설계</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#orm-object-relational-mapping-프레임워크"><strong>ORM( Object-Relational Mapping )프레임워크</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#orm-프레임워크-매핑-기법"><strong>ORM 프레임워크 매핑 기법</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#orm-프레임워크-매핑-기법-1"><strong>ORM 프레임워크 매핑 기법</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#orm-프레임워크-절차"><strong>ORM 프레임워크 절차</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#논리-데이터-저장소-구조"><strong>논리 데이터 저장소 구조</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#트랜잭션-인터페이스"><strong>트랜잭션 인터페이스</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#트랜잭션-인터페이스-설계"><strong>트랜잭션 인터페이스 설계</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#프로시저"><strong>프로시저</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#절차형-데이터-조작-프로시저"><strong>절차형 데이터 조작 프로시저</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#프로그램-디버깅-program-debugging-"><strong>프로그램 디버깅( Program Debugging )</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#프로그램-디버깅-도구"><strong>프로그램 디버깅 도구</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#단위-테스트-도구"><strong>단위 테스트 도구</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#쿼리-query--성능-측정"><strong>쿼리( Query ) 성능 측정</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#sql-성능-개선-절차"><strong>SQL 성능 개선 절차</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#소스-코드-인스펙션-source-code-inspection-"><strong>소스 코드 인스펙션( Source Code Inspection )</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#sql-코드-인스펙션-대상"><strong>SQL 코드 인스펙션 대상</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#sql-코드-인스펙션-절차"><strong>SQL 코드 인스펙션 절차</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#모듈-구현"><strong>모듈 구현</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#단위-모듈-테스트"><strong>단위 모듈 테스트</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#테스트-커버리지"><strong>테스트 커버리지</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#ide-도구"><strong>IDE 도구</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#ide-intergrated-development-environment-"><strong>IDE( Intergrated Development Environment )</strong></a></li>
        <li><a href="#ide-도구의-기능"><strong>IDE 도구의 기능</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#협업-도구"><strong>협업 도구</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#협업-도구의-분류"><strong>협업 도구의 분류</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#형상-관리-도구"><strong>형상 관리 도구</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#형상-관리-도구의-기능"><strong>형상 관리 도구의 기능</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#형상-관리-도구의-사례"><strong>형상 관리 도구의 사례</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#애플리케이션-패키징-application-packaging-"><strong>애플리케이션 패키징( Application Packaging )</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#사용자-관점에서의-패키징-고려사항"><strong>사용자 관점에서의 패키징 고려사항</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#애플리케이션-패키징-프로세스"><strong>애플리케이션 패키징 프로세스</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#애플리케이션-패키징-릴리즈-노트"><strong>애플리케이션 패키징 릴리즈 노트</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#노트-작성-프로세스"><strong>노트 작성 프로세스</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#애플리케이션-배포-도구"><strong>애플리케이션 배포 도구</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#drm-digital-rights-management-"><strong>DRM( Digital Rights Management )</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#drm의-특징"><strong>DRM의 특징</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#drm의-구성요소"><strong>DRM의 구성요소</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#heading-107">**</a></li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
<article class="markdown">
  <h1>
    <a href="/posts/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B3%84%EB%B0%9C/"></a>
  </h1>
  



  

  


  <p><h2 id="데이터-입출력-구현"><strong>데이터 입출력 구현</strong></h2>
<h1 id="heading"></h1>
<h3 id="자료-구조--data-structure-"><strong>자료 구조 ( Data Structure )</strong></h3>
<h1 id="heading-1"></h1>
<ul>
<li>
<p>컴퓨터상 자료를 효율적으로 저장하기 위해 만들어진 논리적인 구조</p>
</li>
<li>
<p>자료 구조의 현명한 선택을 통해 효율적인 알고리즘을 사용할 수 있어 성능을 향샹</p>
</li>
</ul>
<h1 id="heading-2"></h1>
<h3 id="자료-구조의-분류"><strong>자료 구조의 분류</strong></h3>
<h1 id="heading-3"></h1>
<p><img src="/study/D_S.png" alt="D_S" /></p>
<ul>
<li>
<p>자료 구조의 분류는 선형 구조와 비선형 구조로 크게 나뉜다</p>
</li>
<li>
<p>선형 구조에는 배열, 연결 리스트, 스택, 큐 등이 있다</p>
</li>
<li>
<p>비선형 구조엔느 트리, 그래프 등이 존재</p>
</li>
</ul>
<h1 id="heading-4"></h1>
<h3 id="리스트의-종류"><strong>리스트의 종류</strong></h3>
<h1 id="heading-5"></h1>
<pre><code>개념                           |                              설명
------------------------------------------------------------------------------------------------------
선형 리스트 ( Linear List )    | 배열과 같이 연속으로 기억 장소에 저장되는 리스트
                               | 선형 리스트의 대표적인 구조로는 배열 ( Array ) 등이 있음
                               | 가장 간편한 자료 구조로, 접근 구조가 빠름
                               | 자료의 삽입, 삭제 시 기존 자료의 이동이 필요
------------------------------------------------------------------------------------------------------
연결 리스트 ( Linked List )    | 노드의 포인터 부분으로 서로 연결시킨 리스트
                               | 연결하는 방식에 따라 단순 연결 리스트, 원형 연결 리스트, 이중 연결 리스트, 이중원형 연결리스트로 구분
                               | 노드의 삽입, 삭제가 선형 리스트와 달리 편리
                               | 연결을 위한 포인터를 추가되어 저장 공간이 추가로 필요
                               | 포인터를 통해 찾는 시간이 추가되어 순차 리스트에 비해 느림
</code></pre>
<h1 id="heading-6"></h1>
<hr>
<hr>
<h3 id="스택--stack-"><strong>스택 ( Stack )</strong></h3>
<h1 id="heading-7"></h1>
<p><img src="/study/Stack.png" alt="Stack" /></p>
<ul>
<li>한 방향으로만 자료를 넣고 뺼 수 있는 LIFO ( Last-in First Out 형식의 자료구조</li>
</ul>
<h1 id="heading-8"></h1>
<hr>
<hr>
<h3 id="큐--queue-"><strong>큐 ( Queue )</strong></h3>
<h1 id="heading-9"></h1>
<p><img src="/study/Queue.jpg" alt="Stack" /></p>
<ul>
<li>스택과 달리 리스트의 한쪽 끝에서는 사입 작업이 이뤄지고 반대쪽 끝에서는 삭제 작업이 이루어지는 FIFO ( First-in First-Out ) 형식의 자료 구조</li>
</ul>
<h1 id="heading-10"></h1>
<hr>
<hr>
<h3 id="데크--deque-double-ended-queue-"><strong>데크 ( Deque: Double Ended Queue )</strong></h3>
<p><img src="/study/Deque.png" alt="Stack" /></p>
<ul>
<li>큐의 양쪽 끝에서 삽입과 삭제를 할 수 있는 자료 구조</li>
</ul>
<hr>
<hr>
<h1 id="heading-11"></h1>
<h3 id="트리-tree"><strong>트리 Tree</strong></h3>
<h1 id="heading-12"></h1>
<p><img src="/study/Tree.png" alt="Tree" /></p>
<ul>
<li>
<p>데이터들을 계층화 시킨 자료구조</p>
</li>
<li>
<p>인덱스를 조작하는 방법으로 가장 많이 사용하는 구조</p>
</li>
<li>
<p>트리는 노드 ( Node )를 연결하는 링크 ( Link )로 구성</p>
</li>
<li>
<p>배열과 달리 노드들이 포인터로 연겨로디어 노드의 상한선이 없음</p>
</li>
<li>
<p>노드의 최대 수 = 2**n-1 ( n = 노드의 깊이 )</p>
</li>
<li>
<div class="book-expand">
  <label>
    <div class="book-expand-head flex justify-between">
      <span>Tree 용어</span>
      <span>...</span>
    </div>
    <input type="checkbox" class="hidden" />
    <div class="book-expand-content markdown-inner">
      <ul>
<li>
<p>루트 노드 ( Root Node ): 트리에서 부모가 없는 최상위 노드, 트리의 시작점</p>
</li>
<li>
<p>단말 노드 ( Leaf Node ): 자식이 없는 노드, 트리의 가장 말단에 위치</p>
</li>
<li>
<p>레벨 ( Level ): 루트 노드를 기준으로 특정 노드까지의 경로 길이</p>
</li>
<li>
<p>조상 노드 ( Ancestor Node ): 특정 노드에서 루트에 이르는 경로상 모든 노드</p>
</li>
<li>
<p>자식 노드 ( Child Node ): 특정 노드에 연결된 다음 레벨의 노드</p>
</li>
<li>
<p>부모 노드 ( Parent Node ): 특정 노드에 연결된 이전 레벨의 노드</p>
</li>
<li>
<p>형제 노드 ( Sibling ): 같은 부모를 가진 노드</p>
</li>
<li>
<p>깊이 ( Depth, Height ): 트리의 최대 레벨</p>
</li>
<li>
<p>차수 ( Degree ): 특정 노드에 연결된 자식 노드의 수</p>
</li>
</ul>

    </div>
  </label>
</div>

</li>
</ul>
<hr>
<hr>
<h3 id="트리-순회-방법"><strong>트리 순회 방법</strong></h3>
<h1 id="heading-13"></h1>
<ul>
<li>
<p>전위 순회 ( Pre-Order Traversal ): Root &ndash;&gt; Left &ndash;&gt; Right순으로 방문</p>
</li>
<li>
<p>중위 순회 ( In-Order Traversal ): Left &ndash;&gt; Root &ndash;&gt; Right순으로 방문</p>
</li>
<li>
<p>후위 순위 ( Post-Order Traversal ): Left &ndash;&gt; Right -&gt;Root 순으로 방문</p>
</li>
</ul>
<h1 id="heading-14"></h1>
<hr>
<hr>
<h3 id="이진-트리"><strong>이진 트리</strong></h3>
<h1 id="heading-15"></h1>
<p><img src="/study/Binary_Tree.png" alt="Binary_Tree" /></p>
<ul>
<li>
<p>포화 이진 트리 ( Full Binary Tree ): 모든 레벨에서 노드가 꽉 채워진 트리</p>
</li>
<li>
<p>완전 이진 트리 ( Complete Binary Tree ): 마지막 레벨을 제외하고 노드가 채워진 트리</p>
</li>
<li>
<p>편향 이진 트리 ( Skewed Binary Tree ): 노드가 왼쪽이나 오른쪽 한 곳만 노드가 존재하는 트리</p>
</li>
</ul>
<h1 id="heading-16"></h1>
<hr>
<hr>
<h3 id="그래프--graph-"><strong>그래프 ( Graph )</strong></h3>
<h1 id="heading-17"></h1>
<ul>
<li>
<p>노드 ( N: Node )와 노드를 연결하는 간선 ( E: Edge )을 하나로 모아놓은 자료구조</p>
</li>
<li>
<p>트리 ( Tree )는 사이클이 없는 그래프</p>
</li>
<li>
<p>방향성의 우무에 따라 <strong>방향 그래프와 무방향 그래프</strong>로 구분</p>
<ul>
<li>
<p>방향 그래프: 정점을 연결하는 선에 방향이 있는 그래프<br>
<strong>최대 간선수: n(n-1)</strong></p>
</li>
<li>
<p>무방향 그래프: 정점을 연결하는 선에 방향이 없는 그래프<br>
<strong>최대 간선수: n(n-1)/2</strong></p>
</li>
</ul>
</li>
</ul>
<h1 id="heading-18"></h1>
<hr>
<hr>
<h2 id="논리-데이터-저장소"><strong>논리 데이터 저장소</strong></h2>
<h1 id="heading-19"></h1>
<ul>
<li>
<p>업무를 모델링 표기법으로 형상화한 데이터 저장소</p>
</li>
<li>
<p>물리 데이터 저장소와 별개로 사용자 혹은 개발자가 이해하기 쉬운 <strong>논리적인 구조로 추상화</strong>하여 제공</p>
</li>
<li>
<p>논리 데이터 자장소의 구조</p>
<ul>
<li>개체 ( Entity ): 관리할 대상이 되는 실체</li>
<li>속성 ( Attribute ): 관리할 정보의 구체적 항목</li>
<li>관계 ( Relationship ): 개체 간의 대응 관계</li>
</ul>
</li>
</ul>
<h1 id="heading-20"></h1>
<h3 id="논리-데이터-저장소-검증-절차"><strong>논리 데이터 저장소 검증 절차</strong></h3>
<h1 id="heading-21"></h1>
<ol>
<li>
<p><strong>개체 ( Entity ) 확인</strong></p>
<ul>
<li>
<p>입력데이터, 출력 데이터 식별 확인</p>
</li>
<li>
<p>관련 업무와의 연계 데이터 식별확인</p>
</li>
<li>
<p>신규 데이터 요구사항 식별 확인</p>
</li>
</ul>
</li>
<li>
<p><strong>속성 ( Attribute ) 확인</strong></p>
<ul>
<li>
<p>시스템별 데이터베이스 구조, 분산, 백업 현황 파악 수준 점검</p>
</li>
<li>
<p>데이터 속성, 공통코드 파악 수준 점검</p>
</li>
<li>
<p>외부 연계 데이터 속성 파악 수준 점검</p>
</li>
</ul>
</li>
<li>
<p><strong>관계 ( Relation ) 확인</strong></p>
<ul>
<li>
<p>개체 간 관계의 적절성 확인</p>
</li>
<li>
<p>증복 최소화를 통한 무결성 보장 여부 확인</p>
</li>
</ul>
</li>
<li>
<p><strong>데이터 베이스 요구사항 확인</strong></p>
<ul>
<li>
<p>저장 데이터 볼륨, 분산구조, 제약조건에 관한 요구사항 도출/ 분석 확인</p>
</li>
<li>
<p>데이터베이스 백업 및 복수정책 요구사항 확인</p>
</li>
<li>
<p>초기 데이터 구축방안에 대한 요구사항 도출/ 분석 확인</p>
</li>
</ul>
</li>
<li>
<p><strong>데이터 흐름 확인</strong></p>
<ul>
<li>
<p>프로세스별 입출력 데이터 정의 수준 확인</p>
</li>
<li>
<p>프로세스 간 공유 및 연계 데이터 정의 수준 확인</p>
</li>
</ul>
</li>
<li>
<p><strong>데이터 설계 기준 확인</strong></p>
<ul>
<li>
<p>데이터베이스 설계 표준 지침 작성 여부 및 적설성 확인</p>
</li>
<li>
<p>데이터 모델 설계 지침 작성 여부 및 적절성 확인</p>
</li>
</ul>
</li>
<li>
<p><strong>데이터 접근권한 확인</strong></p>
<ul>
<li>
<p>데이터에 접근권한 및 통제 분석 적정성 확인</p>
</li>
<li>
<p>데이터 암호화 대상 소프트웨어 아키텍처 설계 가이드라인 확인</p>
</li>
</ul>
</li>
</ol>
<hr>
<hr>
<h1 id="heading-22"></h1>
<h2 id="물리-데이터-저장소"><strong>물리 데이터 저장소</strong></h2>
<h1 id="heading-23"></h1>
<ul>
<li>논리 데이터 모델을 사용하고자 하는 각 DBMS의 특성을 고려하여 데이터베이스 저장 구조 ( 물리 데이터 모델 )변환하기 위한 데이터 저장소를 의미</li>
</ul>
<h1 id="heading-24"></h1>
<h3 id="물리-데이터-저장소-모델-변환-절차"><strong>물리 데이터 저장소 모델 변환 절차</strong></h3>
<h1 id="heading-25"></h1>
<ol>
<li>
<p><strong>단위 개체를 테이블로 변환 ( 논리 모델에서 정의된 개체 (Entity )는 물리 모델에서 테이블로 변환 )</strong></p>
<ul>
<li>
<p>일반적으로 테이블과 개체 명칭을 동일하게 하는 것을 권고</p>
</li>
<li>
<p>개체는 한글명을 사용</p>
</li>
<li>
<p>테이블은 소스 코드의 가독성을 위해 영문명을 사용</p>
</li>
</ul>
</li>
<li>
<p><strong>속성을 컬럼으로 변환 ( 논리 모델에서 정의된 속성은 물리 모델에서 컬럼으로 변환 )</strong></p>
<ul>
<li>
<p>개발자와 사용자 간 의사소통을 위해 표준화된 약어를 사용하도록 권고</p>
</li>
<li>
<p>SQL 예약어 사용은 피해야 함</p>
</li>
<li>
<p>SQL 문장 가독성을 높이기 위해 컬럼 명칭은 되도록 짧은 것을 권고</p>
</li>
<li>
<p>컬럼명으로 복합단어를 사용할 경우 미리 정의된 표준에 의해 명명해야 함</p>
</li>
</ul>
</li>
<li>
<p><strong>UID 기본 키 ( Primary Key )로 변환 ( 개체의 UID에 해당하는 모든 속성에 대해 기본 키로 선언 )</strong></p>
<ul>
<li>
<p>개체의 UID에 해당하는 모든 속성에 대해 기본 키로 선언</p>
</li>
<li>
<p>Not Null, Unique 등의 제약조건을 추가로 정의</p>
</li>
<li>
<p>관계에 의한 외래 키가 기본키에 포함 될 수 있음</p>
</li>
</ul>
</li>
<li>
<p><strong>관계를 외래 키 ( Foreign Key )로 변환 ( 논리 모델에서 정의된 관계는 외래 키로 변환 )</strong></p>
<ul>
<li>
<p>외래 키 명은 기본키 이름을 그대로 사용하나 다른 의미를 가질 경우 변경 가능</p>
</li>
<li>
<p>순환 관계에서 자신의 기본 키는 외래 키로 정의</p>
</li>
</ul>
</li>
<li>
<p><strong>컬럼 유형 ( Type )와 길이 ( Length ) 정의</strong></p>
<ul>
<li>DBMS에서 제공하는 데이터 유형 중 적절한 유형을 정의하고, 해당 데이터의 최대 길이를 파악하여 길이를 설정</li>
<li><div class="book-expand">
  <label>
    <div class="book-expand-head flex justify-between">
      <span>자주 사용되는 데아터 유형 ( Oracle )</span>
      <span>...</span>
    </div>
    <input type="checkbox" class="hidden" />
    <div class="book-expand-content markdown-inner">
      <pre><code>- CHAR: 최대 2000btye의 고정 길이 문자열 저장 가능
- VARCHAR2: 최대 4000byte의 가변 길이 문자열 저장 기능
- NUMBER: 38자릿수의 숫자 저장 가능
- DATE: 날짜 값을 저장
- BLOB, CLOB: 바이너리 ( Binary ), 텍스트 데이터 최대 4GB까지 저장 가능
</code></pre>
    </div>
  </label>
</div>
</li>
</ul>
</li>
<li>
<p><strong>반 정규화 ( De-normalization ) 수행 ( 시스템 성능 향상과 개발 및 운영의 단순화를 위해 데이터 모델을 통합하는 반 정규화를 수행</strong></p>
<ul>
<li><strong>반 정규화 수행 방법</strong></li>
</ul>
<ol>
<li>
<p>증복 테이블 추가: 집계 테이블, 특정 부분만 포함하는 테이블 추가</p>
</li>
<li>
<p>테이블 조합: 1:1, 1:M, 슈퍼 타입/ 서브 타입 테이블 조합</p>
</li>
<li>
<p>테이블 분할: 수직분할, 수평분할</p>
</li>
<li>
<p>테이블 제거: 테이블 재정의 접근하지 않는 테이블 제거</p>
</li>
<li>
<p>컬럼 중복화, 조인 성능 향상을 위한 중복 허용</p>
</li>
</ol>
</li>
</ol>
<h1 id="heading-26"></h1>
<hr>
<hr>
<h2 id="물리-데이터-저장소-구성"><strong>물리 데이터 저장소 구성</strong></h2>
<h1 id="heading-27"></h1>
<ul>
<li>DBMS를 선정한 이후 물리 데이터 저장소 구성을 위한 활동</li>
</ul>
<h1 id="heading-28"></h1>
<h3 id="테이블-제약조건--constraint-설계"><strong>테이블 제약조건 ( Constraint )설계</strong></h3>
<h1 id="heading-29"></h1>
<pre><code>제약 조건                              |     옵션           |           설명
--------------------------------------------------------------------------------------------------------------------------
삭제 제약 조건 ( Delete Constraint )    | 연쇄 ( Cascade)    | 참조한 테이블에 있는 외부 키와 일치하는 모든 Row가 삭제
                                      | 제한 ( Restricted) | 참조한 테이블에 있는 외부 키에 없는 것만 삭제 가능
                                      | 무효 ( Nullify )   | 참조한 테이블에 정의된 외부 키와 일치하는 것을 Null로 수정
--------------------------------------------------------------------------------------------------------------------------
갱신 제약 조건 ( Update Constraint )    | 연쇄 ( Cascade)    | 참조한 테이블에 있는 외부 키와 일치하는 모든 Row가 수정
                                      | 제한 ( Restricted) | 참조한 테이블에 있는 외부 키에 없는 것만 수정 가능
                                      | 무효 ( Nullify )   | 참조한 테이블에 정의된 외부 키와 일치하는 것을 Null로 수정
</code></pre>
<hr>
<hr>
<h1 id="heading-30"></h1>
<h3 id="인덱스--index--설계"><strong>인덱스 ( Index ) 설계</strong></h3>
<pre><code>- 인덱스 적용 기준, 컬럼 선정, 고려사항 등을 고려하여 설계
- 인덱스 적용 기준 ( 인덱스 분포도가 10~ 15% 이내인 경우): 
    * 분포도: ( 1/ ( 컬럼 값의 종류 )X 100 )
    * ( 컬럼 값의 평균 ROw 수 )/ ( 테이블의 총 Row 수 ) X 100
</code></pre>
<h1 id="heading-31"></h1>
<ul>
<li><strong>인덱스 컬럼 설정</strong>
<ul>
<li>
<p>분포도가 좋은 컬럼은 단독적으로 생성</p>
</li>
<li>
<p>자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성</p>
</li>
<li>
<p>결합 인덱스는 구성되는 컬럼 순서 선정 ( 사용빈도, 유일성, 정렬 등 )에 유의</p>
</li>
<li>
<p>가능한 한 수정이 번번하지 않은 컬럼을 선정</p>
</li>
</ul>
</li>
</ul>
<h1 id="heading-32"></h1>
<ul>
<li><strong>설계시 고려사항</strong>
<ul>
<li>
<p>지나치게 많은 인덱스는 오베헤드( Overhead )로 작용</p>
</li>
<li>
<p>인덱스는 추가적인 저장 공간이 필요함을 고려해야 한다</p>
</li>
<li>
<p>넓은 범위를 인덱스 처리 시 오히려 전체 처리보다 많은 오버헤드를 발생시킬 수 있음에 유의</p>
</li>
<li>
<p>인덱스와 테이블의 저장 공간을 적절히 분리될 수 있도록 설계</p>
</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h1 id="heading-33"></h1>
<h3 id="뷰-view--설계"><strong>뷰( View ) 설계</strong></h3>
<h1 id="heading-34"></h1>
<ul>
<li>
<p><strong>뷰의 속성</strong></p>
<ul>
<li>REPLACE: 뷰가 이미 존재하는 경우 재성성</li>
<li>FORCE: 본 테이블의 존재 여부에 관계 없이 뷰 생성</li>
<li>NOFORCE: 기본 테이블이 존재할 때 뷰 생성</li>
<li>WITH CHECK OPTION: 서브 쿼리 내의 조건을 만족하는 행만 변경</li>
<li>WITH READ ONLY: 데이터 조작어( DML ) 작업 불가</li>
</ul>
</li>
<li>
<p><strong>뷰 설계시 고려사항</strong></p>
<ul>
<li>뷰 사용에 따라 수행속도에 문제가 발생할 수 있다.</li>
<li>뷰 SELECT 문의 조건은 최적의 엑세스 경로를 사용할 수 있도록 한다.</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h1 id="heading-35"></h1>
<h3 id="클러스터-cluster--설계"><strong>클러스터( Cluster ) 설계</strong></h3>
<h1 id="heading-36"></h1>
<ul>
<li>
<p><strong>클러스터의 적용 기준</strong></p>
<ul>
<li>
<p>인덱스의 단점을 ㅎ결한 기법으로, 분포도가 넓을수록 유리</p>
</li>
<li>
<p>액세스 기법이 아니라 액세스 효율 향상을 위한 물리적 저장방법</p>
</li>
<li>
<p>분포도가 넓은 테이블의 클러스터링은 저장 공간의 절약이 가능</p>
</li>
<li>
<p>대량의 범위를 자주 엑세스하는 경우 적용</p>
</li>
<li>
<p>인덱스를 사용한 처리 부담이 되는 넓은 분포도에 활용</p>
</li>
<li>
<p>여러 개의 테이블이 번번하게 조인을 일으킬 때 활용</p>
</li>
</ul>
</li>
<li>
<p><strong>클러스터 설계 시 고려사항</strong></p>
<ul>
<li>
<p>검색 효율은 높여 주나 입력, 수정, 삭제 시는 부하가 증가함을 고려</p>
</li>
<li>
<p>UNION, DISTINCT, ORDER BY, GROUP BY가 빈번한 컬럼이면 검토 대상</p>
</li>
<li>
<p>수정이 자주 발생하지 않는 컬럼은 검토 대상</p>
</li>
<li>
<p>처리 범위가 넓어 문제가 발생하는 경우는 단일 테이블 클러스터링을 고려</p>
</li>
<li>
<p>조인이 많아 문제가 발생되는 경우는 다중 테이블 클러스터링을 고려</p>
</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h1 id="heading-37"></h1>
<h3 id="파티션-partition--설계"><strong>파티션( Partition ) 설계</strong></h3>
<h1 id="heading-38"></h1>
<ul>
<li><strong>파티션의 종류</strong>
<ul>
<li>레인지 파티셔닝( Range Partitioning ): 지정한 열의 값을 기준으로 분할</li>
<li>해시 파티셔닝( Hash Partitioning ): 해시 함수에 따라 데이터를 분할</li>
<li>리스트 파티셔닝( List Partitioning ): 미리 정해진 그룹핑 기준에 따라 데이터를 분할</li>
<li>컴포지트 파티셔닝( Composite Partitioning ): 범위 분할에 이후 해시 함수를 적용하여 재분할</li>
</ul>
</li>
<li><strong>파티션의 장점</strong>
<ul>
<li>성능 향상: 데이터 엑세스 범위를 줄여 성능 향상</li>
<li>가용성 향상: 전체 데이터의 훼손 가능성이 감소 및 데이터 가용성 향상</li>
<li>백업 가능: 분할 영역을 독립적으로 백업하고 복구 가능</li>
<li>경합 감소: 디스크 스트라이핑으로 입출력 성능을 향ㅅ아 가능, 디스크 컨트롤러에 대한 경합의 감소</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h1 id="heading-39"></h1>
<h3 id="디스크-disk-구성-설계"><strong>디스크( Disk )구성 설계</strong></h3>
<h1 id="heading-40"></h1>
<ul>
<li>정확한 용량을 산정하여 디스크 사용의 효율을 높인다</li>
<li>업무량이 집중되어 있는 디스크를 분리하여 설계</li>
<li>입출력 경합을 최소화하여 데이터의 접근 성능을 향상</li>
<li>디스크 구성에 따라 테이블스페이스 개수와 사이즈 등을 결정</li>
<li>파티션 수행 테이블은 별도로 분류</li>
</ul>
<hr>
<hr>
<h1 id="heading-41"></h1>
<h2 id="orm-object-relational-mapping-프레임워크"><strong>ORM( Object-Relational Mapping )프레임워크</strong></h2>
<h1 id="heading-42"></h1>
<p><img src="/study/ORM.jpg" alt="ORM" /></p>
<ul>
<li>
<p>관계형 데이터베이스와 객체지향 프로그래밍 언어 간 호환되지 않은 데이터를 변환하는 프로그래밍 기법</p>
</li>
<li>
<p>객체지향 언어에서 사용하는 객체를 관계형 데이터베이스로 변환하여 테이블을 구성하는 활용</p>
</li>
</ul>
<h1 id="heading-43"></h1>
<h3 id="orm-프레임워크-매핑-기법"><strong>ORM 프레임워크 매핑 기법</strong></h3>
<ul>
<li>
<p>ORM 프레임워크에는 크게 SQL, Mapping기반 기술과 OR Mapping 기반 기술로 구분</p>
</li>
<li>
<p>SQL Mapping 기반 기술로는 iBatis, Mybatis가 있고, OR Mapping 기반 기술로는 Hibernate 등이 있다</p>
</li>
</ul>
<h1 id="heading-44"></h1>
<h3 id="orm-프레임워크-매핑-기법-1"><strong>ORM 프레임워크 매핑 기법</strong></h3>
<ul>
<li>ORM 프레임워크를 통해 객체와 테이블 간의 변환방법을 제공
<ul>
<li>객체/ 테이블/ 객체 지향 내 객체는 데이터베이스에서 테이블로 변환</li>
<li>속성/ 컬럼/ 객체의 속성은 데이터베이스에서 컬럼으로 변환</li>
<li>오퍼레이션/ 프로시져, 함수/ 객체의 행위인 오퍼레이션은 데이터베이스에서 프로시저 또는 함수로 변환</li>
</ul>
</li>
</ul>
<h1 id="heading-45"></h1>
<h3 id="orm-프레임워크-절차"><strong>ORM 프레임워크 절차</strong></h3>
<h1 id="heading-46"></h1>
<ol>
<li>
<p>클래스 &ndash;&gt; 테이블 변환: 클래스의 인스턴스는 테이블 레코드로 변환</p>
</li>
<li>
<p>애트리뷰트 &ndash;&gt; 컬럼 변환: 클래스 인스턴스의 애트리뷰트는 테이블 컬럼으로 변환</p>
</li>
<li>
<p>클래스 간 관계 &ndash;&gt; 테이블 간 관계 변환: 클래스 간 관계를 데이터베이스의 테이블 제약사항으로 변환</p>
</li>
</ol>
<h1 id="heading-47"></h1>
<h3 id="논리-데이터-저장소-구조"><strong>논리 데이터 저장소 구조</strong></h3>
<h1 id="heading-48"></h1>
<pre><code>    구분            |                   부분적 ORM               |                  완전 ORM
    ------------------------------------------------------------------------------------------------
    개요            | SQL을 특정이름으로 정의하여 사용            | 내부엔진에서 SQL 자동생성
    매퍼 사용       | SQL Mapper                                 | Object Relation Mapper
    방법            | iBatis, MyBatis, Embeded SQL               | Hibernate
    장점            | 데이터 전송 방식의 효율성                   | 효율적인 매핑 기법
</code></pre>
<h1 id="heading-49"></h1>
<hr>
<hr>
<h2 id="트랜잭션-인터페이스"><strong>트랜잭션 인터페이스</strong></h2>
<h1 id="heading-50"></h1>
<ul>
<li>
<p>데이터베이스 트랜잭션의 공격 및 인터페이스를 정의하는 활동</p>
</li>
<li>
<p>트랜잭션은 데이터베이스의 입출력과 기능적 형태로 정의</p>
</li>
<li>
<p>트랜잭션 인터페이스는 ACID 원칙을 기반으로 설계</p>
<ul>
<li>원자성( Atomicity ): 트랜잭션 연산을 데이터베이스 모두에 반영 또는 반영하지 말아야 함 ( All or Nothing )</li>
<li>일관성( Consistency ): 트랜잭션이 실행을 성공적으로 완료할시 일관성 있는 데이터베이스 상태를 유지</li>
<li>독립성( Isolation ): 둘 이상의 트랜잭션 동시 실행 시 한 개의 트랜잭션만 접근이 가능하여 간섭불가</li>
<li>영속성( Durability ): 성공적으로 완료된 트랜잭션 결과는 영구적으로 반영</li>
</ul>
</li>
</ul>
<h1 id="heading-51"></h1>
<h3 id="트랜잭션-인터페이스-설계"><strong>트랜잭션 인터페이스 설계</strong></h3>
<h1 id="heading-52"></h1>
<ul>
<li>
<p>데이터 접근 방법 및 인터페이스를 절차적으로 명세</p>
</li>
<li>
<p>트랜잭션 인터페이스는 주로 프로그래밍 언어로 구현</p>
</li>
<li>
<p>대표적인 사례로 JDBC( Java Database Connetivity, ODBC( Open DataBase Connectivity ))등이 있다</p>
</li>
</ul>
<h1 id="heading-53"></h1>
<h2 id="프로시저"><strong>프로시저</strong></h2>
<h1 id="heading-54"></h1>
<ul>
<li>
<p>SQL를 이용해 생성된 데이터를 <strong>조작하는 프로그램</strong></p>
</li>
<li>
<p>데이터베이스 내부에 저장되고 일정한 조건이 되면 자동으로 수행</p>
</li>
</ul>
<h1 id="heading-55"></h1>
<h3 id="절차형-데이터-조작-프로시저"><strong>절차형 데이터 조작 프로시저</strong></h3>
<ul>
<li>
<p>절차형 데이터 조작 프로시저를 Oracle PL/ SQL 기반으로 설명</p>
<ol>
<li>
<p><strong>Oracle 기반 PL/ SQL 개념</strong></p>
<ul>
<li>
<p>표준 SQL을 기본으로 Oracle에서 개발한 데이터 조작 언어</p>
</li>
<li>
<p>Oracle 기반의 모든 프로시저 작성에 사용되며 표준 SQL의 확징 기능이 우수</p>
</li>
</ul>
</li>
<li>
<p><strong>PL/ SQL의 장점</strong></p>
<ul>
<li>
<p>컴파일 불필요: 컴파일 없이 스크립트 생성 및 변경 후 실행가능</p>
</li>
<li>
<p>모듈화 가능: 블록 내에서 논리적으로 관련된 문장 그룹화 가능</p>
</li>
<li>
<p>데이텁이스의 테이블과 레코드를 기반으로 하는 동적변수 선언 가능, 단일형 데이터 타입과 복합형 데이터 타입 선언가능</p>
</li>
<li>
<p>에러처리: 예외처리 루틴을 이용한 에러 처리 가능</p>
</li>
</ul>
</li>
<li>
<p><strong>PL/ SQL의 구성</strong></p>
<ul>
<li>
<p>선언부( Declare ): 실행부에서 참조할 모든 변수, 상수, CURSOR, EXCEPTION을 선언</p>
</li>
<li>
<p>실행부( Begin/ End): Begin과 End 사이에 기술되는 영역, 데이터를 처리할 SQL문과 PL/ SQL 블록을 기술</p>
</li>
<li>
<p>예외부( Exception ): 실행부에서 에러가 발생했을 때 문장 기술</p>
</li>
</ul>
</li>
<li>
<p><strong>PL/ SQL을 활용한 저장형 객체 활용</strong></p>
<pre><code> 구분                                | 설명
 -----------------------------------------------------------------------------------------------------------------------------------------
 저장된 프로시저( Stored Procedure )  | 작성한 PL/ SQL을 저장해 놓고 필요한 경우 추출
 저장된 함수( Stored Fuction )        | 저장 프로시저와 용도는 비슷하나, 실행결과를 되돌려 받을 수 있음
 저장된 패키지( Stored Package )      | 프로시저나 함수를 효율적으로 관리하기 위해 패키지 단위로 배포할 때 사용
 트리거( Trigger )                    | 특정 테이블에 삽입, 수정, 삭제 등의 데이터 변경 이벤트가 발생 시 DBMS에서 자동적으로 실행되도록 구현된 프로그램
</code></pre>
</li>
</ol>
</li>
</ul>
<hr>
<hr>
<h1 id="heading-56"></h1>
<h2 id="프로그램-디버깅-program-debugging-"><strong>프로그램 디버깅( Program Debugging )</strong></h2>
<h1 id="heading-57"></h1>
<ul>
<li>
<p>프로시저가 입력 자료를 받아 출력을 올바르게 도출하는지에 관한 확인 과정</p>
</li>
<li>
<p>데이터베이스 프로시저에 대한 검증 작업을 프로그램 디버깅이라 함</p>
</li>
</ul>
<h1 id="heading-58"></h1>
<h3 id="프로그램-디버깅-도구"><strong>프로그램 디버깅 도구</strong></h3>
<h1 id="heading-59"></h1>
<ul>
<li>
<p>프로시저의 디버깅을 위해 SQL Plus라는 도구를 이용</p>
</li>
<li>
<p>SQL PLUS는 SQL을 DBMS 서버에 전송하여 처리할 수 있또록 하는 Oracle에서 제공하는 도구</p>
</li>
<li>
<p>주요 명령어로는 파일 명령어, 편짐 명령어, 실행 명령어, 환경 명령어, 형식 명령어, 대화 명령어 등이 있다</p>
</li>
</ul>
<h1 id="heading-60"></h1>
<h3 id="단위-테스트-도구"><strong>단위 테스트 도구</strong></h3>
<h1 id="heading-61"></h1>
<ul>
<li>
<p>구현된 프로시저의 적합성을 확인하기 위한 방법을 제공하는 도구</p>
</li>
<li>
<p>Oracle DBMS는 모든 데이터 조작 프로시저에 대한 테스트 환경으로 SQL Plus 기반의 PL/ SQL을 활용</p>
</li>
</ul>
<h1 id="heading-62"></h1>
<hr>
<hr>
<h2 id="쿼리-query--성능-측정"><strong>쿼리( Query ) 성능 측정</strong></h2>
<h1 id="heading-63"></h1>
<ul>
<li>데이터베이스에서 프로시저에 있는 SQL 실행 계획을 분석, 수정을 통해 최소의 시간으로 원하는 결과를 얻도록 프로시저를 수정하는 사전 작업, 쿼리 성능을 측정하는 방법은 EXPLAIN PLAN을 주로 활용</li>
</ul>
<h1 id="heading-64"></h1>
<h3 id="sql-성능-개선-절차"><strong>SQL 성능 개선 절차</strong></h3>
<h1 id="heading-65"></h1>
<ol>
<li>
<p><strong>문제 있는 SQL 식별:</strong> 문제 있는 SQL을 식별하기 위해 애플리케이션의 성능을 관리 툴인 APM 등을 사용</p>
</li>
<li>
<p><strong>옵티마이저 통계 확인:</strong> 옵티마이저는 개발자가 작성한 SQL문을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 데이터베이스 핵심 모듈</p>
</li>
<li>
<p><strong>SQL문 재구성:</strong> 범위가 아닌 특정 값 지정으로 범위를 줄여 처리속도가 빠르게 함, 옵티마이저가 비정상적인 실행계획을 수립중일 경우 힌트를 제시</p>
</li>
<li>
<p><strong>인덱스의 재구성:</strong> 성능에 중요한 엑세스 경로를 고려하여 인덱스 생성 및 실행계획을 검토하여 기존 인덱스의 열 순서를 변경/ 추가</p>
</li>
<li>
<p><strong>실행계획 유지관리:</strong> 데이터베이스 버전 업그레이드, 데이터 전환 등 시스템 환경의 변경 사항 발생 시에도 실행계획이 유지되고 있는지 관리</p>
</li>
</ol>
<h1 id="heading-66"></h1>
<h2 id="소스-코드-인스펙션-source-code-inspection-"><strong>소스 코드 인스펙션( Source Code Inspection )</strong></h2>
<h1 id="heading-67"></h1>
<ul>
<li>
<p>데이터베이스 성능 향상을 위하여 프로시저 코드를 보면서 성능 문제점을 개선해 나가는 활동</p>
</li>
<li>
<p>데이터 조작 프로시저 최적화를 위한 SQL 코드 인스펙션이 있다</p>
</li>
</ul>
<h1 id="heading-68"></h1>
<h3 id="sql-코드-인스펙션-대상"><strong>SQL 코드 인스펙션 대상</strong></h3>
<h1 id="heading-69"></h1>
<ul>
<li>
<p><strong>미사용 변수:</strong> 프로시저에서 선언은 되었지만 본문에서는 전혀 사용되지 않는 변수</p>
</li>
<li>
<p><strong>미사용 서브쿼리:</strong> 컬럼이 선언은 되었지만 외부 쿼리에서 참조가 되지 않음</p>
</li>
<li>
<p><strong>Null 값 비교:</strong> Null 값과 비교하는 프로시저 소스가 있는 경우</p>
</li>
<li>
<p><strong>과거의 데이터 타입 사용:</strong> 데이터 타입이 바뀌었지만 과거의 타입을 그대로 쓰는 소스가 있는 경우</p>
</li>
</ul>
<h1 id="heading-70"></h1>
<h3 id="sql-코드-인스펙션-절차"><strong>SQL 코드 인스펙션 절차</strong></h3>
<h1 id="heading-71"></h1>
<ol>
<li>
<p><strong>계획 단계:</strong> 문제되는 SQL 코드 식별, 문제점 인식 및 인스펙션 참여자 설정</p>
</li>
<li>
<p><strong>개관 단계:</strong> SQL 코드 문제점 공유( 실행시간, 자원 사용량 등 )</p>
</li>
<li>
<p><strong>준비 단계:</strong> 개별 SQL 소스 코드 분석, 문제점 확인</p>
</li>
<li>
<p><strong>검사 단계:</strong> 문제점 토의</p>
</li>
<li>
<p><strong>재작업 단계:</strong> SQL 소스 코드 수정 및 실행 시간 재측정</p>
</li>
<li>
<p><strong>추적 단계:</strong> 팔로우 업, 개선 효과 분석</p>
</li>
</ol>
<h1 id="heading-72"></h1>
<hr>
<hr>
<h2 id="모듈-구현"><strong>모듈 구현</strong></h2>
<h1 id="heading-73"></h1>
<ul>
<li>소프트웨어 개발에 있어 기능을 분할하고 추상화하여 성능을 향상시키고 유지보수를 효과적으로 하기위한 <strong>단위 컴포넌트별 구현 기법</strong></li>
</ul>
<h1 id="heading-74"></h1>
<ul>
<li><strong>단위 모듈 구현의 원리</strong>
<ul>
<li>
<p><strong>정보 은닉( Information Hiding ):</strong> 어렵거나 변경 가능성이 있는 모듈을 타 모듈로부터 은폐</p>
</li>
<li>
<p><strong>분할과 정복( Divde &amp; Conquer ):</strong> 복잡한 문제를 분해, 모듈 단위로 문제 해결</p>
</li>
<li>
<p><strong>데이터 추상화( Data Abstraction ):</strong> 각 모듈 자료 구조를 엑세스하고 수정하는 함수내에 자료 구조의 표현내역을 은폐</p>
</li>
<li>
<p><strong>모듈 독립성( Module Independency ):</strong> 낮은 결합도와 높은 응집도를 가짐</p>
</li>
</ul>
</li>
</ul>
<h1 id="heading-75"></h1>
<h3 id="단위-모듈-테스트"><strong>단위 모듈 테스트</strong></h3>
<h1 id="heading-76"></h1>
<ul>
<li>
<p>단위 모듈 테스트를 위해 <strong>IDE( Intergrated Development Environment )도구를 활용</strong>하여 개별 단위 모듈에 대한 디버깅을 수행</p>
</li>
<li>
<p>단위 모듈 테스트는 화이트 박스 기법을 사용</p>
</li>
<li>
<p><strong>단위 모듈 테스트의 종류</strong></p>
<ul>
<li>
<p><strong>화이트 박스 테스트:</strong> 단위 모듈 테스트의 가장 기본적 방법은 모듈 내부의 소스를 보면서 수행하는 화이트박스 테스트</p>
</li>
<li>
<p><strong>메소드 기반 테스트:</strong> 단이 모듈의 외부에 공개된 메소드 기반의 테스트</p>
</li>
<li>
<p><strong>화면 기반 테스트:</strong> 사용자용 화면이 있는 경우, 각각의 화면단위로 단위 모듈을 개발 후에 화면에 직접 데이터를 입력하여 테스트 수행</p>
</li>
<li>
<p><strong>테스트 드라이버, 테스트 스텁:</strong> 기능을 테스트할 수 있는 화면 또는 하위 모듈이 구현 되지 않은 경우 테스트 드라이버, 테스트 스텁을 통해 테스트 수행</p>
</li>
</ul>
</li>
</ul>
<h1 id="heading-77"></h1>
<h3 id="테스트-커버리지"><strong>테스트 커버리지</strong></h3>
<h1 id="heading-78"></h1>
<ul>
<li>
<p>프로그램의 테스트 수행 정도를 나타내는 값으로 테스트 수행의 완벽성을 측정하는 도구</p>
</li>
<li>
<p><strong>테스트 커버리지의 유형</strong></p>
<ul>
<li>
<p><strong>구문 커버리지:</strong> 프로그램 내 모든 문장을 적어도 한 번 이상 실행하는 것을 기준으로 수행하는 테스트 커버리지</p>
</li>
<li>
<p><strong>결정 커버리지:</strong> 결정 조건 내 전체 조건식이 최소한 참/ 거짓 한 번 값을 가지도록 측정하는 테스트 커버리지</p>
</li>
<li>
<p><strong>조건 커버리지:</strong> 전체 조건식 결과와 관계없이 각 개별 조건식이 참/ 거짓 한번 모두 갖도록 개별 조건식을 조합하는 테스트 커버리지</p>
</li>
<li>
<p><strong>조건/ 결정 커버리지:</strong> 전체 조건식이 참/ 거짓 한 번씩 가지면서, 개별 조건식이 참/ 거짓 모두 한 번씩 갖도록 조합하는 테스트 커버리지</p>
</li>
<li>
<p><strong>변경 조건/ 결정 커버리지:</strong> 각 개별 조건식이 다른 개별 조건식의 영향을 받지 않고 전체 조건식의 결과에 독립적으로 영향을 주도록 함으로써 조견/ 결정 커버리지를 향상시킨 테스트 커버리지</p>
</li>
<li>
<p><strong>다중 조건 커버리지:</strong> 결정 조건 내 모든 개발 조건식의 모든 가능한 조합을 100% 보장하는 테스트 커버리지</p>
</li>
</ul>
</li>
</ul>
<h1 id="heading-79"></h1>
<hr>
<hr>
<h2 id="ide-도구"><strong>IDE 도구</strong></h2>
<h1 id="heading-80"></h1>
<h3 id="ide-intergrated-development-environment-"><strong>IDE( Intergrated Development Environment )</strong></h3>
<ul>
<li>
<p>코딩 디버그 배포 등 프로그램 개발과 관련된 모든 작업을 하나의 프로그램 안에서 처리하는 환경을 제공하는 소프트웨어</p>
</li>
<li>
<p>기존 컴파일러( Compiler ), 텍스트 편집기( Editor ), 디버거( Debugger )를 따로 사용하였으나 통합 개발환경을 통해 하나의 묶은 대화형 인터페이스를 제공</p>
</li>
</ul>
<h3 id="ide-도구의-기능"><strong>IDE 도구의 기능</strong></h3>
<pre><code>- **개발환경 지원:** 자바, 파이썬 등 개발언어를 통해 어플리케이션 개발환경 제공

- **컴파일:** 문법에 어긋나는지 확인하고 기계어로 변환하는 기능 제공
- **디버깅:** 프로그래밍 과정에 발생하는 오류 및 비정상적인 연산 제거
- **외부연계:** 외부 형상, 배포관리 기능과 연계되어 자동 배포등이 가능
- **DB 연동:** JDBC, ODBC 등을 통한 데이터베이스 연동
</code></pre>
<h1 id="heading-81"></h1>
<hr>
<hr>
<h2 id="협업-도구"><strong>협업 도구</strong></h2>
<h1 id="heading-82"></h1>
<ul>
<li>다른 개발자와 유대감을 형성하거나 유지하기 위해서 지속적으로 커뮤니케이션을 수행하기 위한 도구</li>
</ul>
<h3 id="협업-도구의-분류"><strong>협업 도구의 분류</strong></h3>
<ul>
<li>
<p><strong>문서 공유 ( Google Drive ):</strong> 팀원 고객 문서를 공유하거나 공동 작업가능</p>
</li>
<li>
<p><strong>소스 공유 ( Github ):</strong> 오픈소스 프로젝트 등 진행 및 소스공유</p>
</li>
<li>
<p><strong>아이디어 공유 ( Evernote ):</strong> 팀원 간 아이디어 공유, 기사 스크랩 등</p>
</li>
<li>
<p><strong>디자인 공유 ( Red pen ):</strong> 웹 디자이너 친화 협업 도구</p>
</li>
<li>
<p><strong>마인드 맵 ( Mind Meister ):</strong> 공동의 브레인스토밍 지원 마인드맵 도구</p>
</li>
<li>
<p><strong>프로젝트 관리 ( Trello, Redmine, Jrea):</strong> 최신 트렌드, 다수의 프로젝트, 프로젝트 이슈 트래킹 기반 협업 도구</p>
</li>
<li>
<p><strong>일정관리 ( Google Calender ):</strong> 구글 제공 캘린더 내 다수 일정 공유 가능</p>
</li>
<li>
<p>협업 도구의 기능( 개발자 간 커뮤니케이션, 일정 및 이슈 공유, 개발자 간 집단 지성 활용 )</p>
</li>
</ul>
<hr>
<hr>
<h1 id="heading-83"></h1>
<h2 id="형상-관리-도구"><strong>형상 관리 도구</strong></h2>
<h1 id="heading-84"></h1>
<ul>
<li>
<p>소프트웨어 변경 사항을 관리하기 위해서 <strong>형상 식별, 통제, 감사, 기록을 수행</strong>하는 도구</p>
</li>
<li>
<p>소스코드나 문서의 버전 관리, 이력 관리, 추적 등 변경 사항을 체계적으로 관리할 수 있는 기능을 제공하는 도구</p>
</li>
<li>
<p>대표 제품으로 CVS, SVN, Git이 있다</p>
</li>
</ul>
<h1 id="heading-85"></h1>
<h3 id="형상-관리-도구의-기능"><strong>형상 관리 도구의 기능</strong></h3>
<h1 id="heading-86"></h1>
<ul>
<li>
<p><strong>체크인:</strong> 개발자가 수정한 소스를 형상 관리 저장소에 업로드</p>
</li>
<li>
<p><strong>체크아웃:</strong> 형상 관리 저장소로부터 최신 버전을 개발자 PC로 다운로드 받는 기능</p>
</li>
<li>
<p><strong>커밋:</strong> 개발자가 소스를 형상 관리 저장소에 업로드 후 최종적으로 업데이트가 되었음을 때에 형상 관리 서버에 반양하도록 하는 기능</p>
</li>
</ul>
<h1 id="heading-87"></h1>
<h3 id="형상-관리-도구의-사례"><strong>형상 관리 도구의 사례</strong></h3>
<h1 id="heading-88"></h1>
<ul>
<li><strong>CVS( Concurrent Versions System )</strong>
<ul>
<li>
<p>가장 오래된 형상 관리 도구 중의 하나로 <strong>중앙 집중형 서버 저장소</strong>를 두고 클라이언트가 접속해 버전을 관리</p>
</li>
<li>
<p>직관적이고 비교적 단순한 명령세트를 가지고 있으나, 텍스트 기반 소스 코드 위주 지원 및 커밋 실패 등에 대한 롤백 기능 미지원</p>
</li>
</ul>
</li>
</ul>
<h1 id="heading-89"></h1>
<ul>
<li><strong>SVN( Subversion )</strong>
<ul>
<li>CVS를 대체하기 위해 만든 도구로 CVS와 사용법이 유사, CVS에서 제공하는 대부분의 명령어 수행 가능, 롤백 기능 지원</li>
<li>디렉토리 파일을 자유롭게 이동 가능, CVS에 비해 빨라진 속도, Gzip을 활용한 공간절약 가능</li>
<li>Trunk, Branch, Tag가 모두 물리적 저장 위치 점유, 잦은 커밋으로 인해 리비전 번호가 크게 증가할 수 있음</li>
</ul>
</li>
</ul>
<h1 id="heading-90"></h1>
<ul>
<li><strong>GIt</strong>
<ul>
<li>GIt는 중앙 집중형 방식이 아닌 분산형 방식으로 각 PC 스스로 완전히 저장소가 구성되며, 필요에 따라 중장 집중형으로도 운영가능</li>
<li>저장의 완전한 복사본 로컬 저장 가능, 로컬 저장을 통해 오프라인 작업 가능, 일시적인 작업에대한 이력 관리가 쉬움</li>
<li>대용량 코드 관리에 부적절, 한번에 diff를 보기 어려움</li>
</ul>
</li>
</ul>
<h1 id="heading-91"></h1>
<hr>
<hr>
<h2 id="애플리케이션-패키징-application-packaging-"><strong>애플리케이션 패키징( Application Packaging )</strong></h2>
<h1 id="heading-92"></h1>
<ul>
<li>
<p>개발이 완료된 제품 소프트웨어를 배포하고 설치할 수 있도록 고객에게 전달하기 위한 형태로 제작 및 설치와 사용에 필요한 제반 내용을 포함하는 메뉴얼을 작성하는 활동</p>
</li>
<li>
<p>어플리케이션 패키징은 <strong>사용자 중심으로 진행</strong>되며, 신규 및 변경 개발 소스를 식별하고, 이를 모듈화하여 상용 제품으로 패키징</p>
</li>
</ul>
<h3 id="사용자-관점에서의-패키징-고려사항"><strong>사용자 관점에서의 패키징 고려사항</strong></h3>
<ul>
<li>
<p><strong>사용자 시스템 환경정의:</strong> 사용자의 시스템 환경인 운영체제, CPU, 메모리 등의 수행을 위한 최소환경을 정의</p>
</li>
<li>
<p><strong>UI 제공:</strong> 사용자가 직관적으로 확인할 수 있는 UI를 제공하고 메뉴얼과 일치시켜 패키징 작업을 수행</p>
</li>
<li>
<p><strong>관리 서비스 형태로 제공:</strong> 애플리케이션은 하드웨어와 함께 통합 적용할 수 있또록, 패키징 관리 서비스 형태로 제공</p>
</li>
<li>
<p><strong>패키징의 변경 및 개선 관리 고려:</strong> 다양한 사용자의 요구사항을 반영하기 위해 패키징의 변경 및 개선 관리를 고려하여 패키징 배포</p>
</li>
</ul>
<h1 id="heading-93"></h1>
<h3 id="애플리케이션-패키징-프로세스"><strong>애플리케이션 패키징 프로세스</strong></h3>
<ol>
<li>
<p><strong>기능식별:</strong> 입출력 데이터 식별, 전체적인 기능 정의 및 데이터 흐름 식별</p>
</li>
<li>
<p><strong>모듈화:</strong> 모듈로 분류할 수 있는 기능 및 서비스 단위 분류, 기능의 공유와 재활용 분류</p>
</li>
<li>
<p><strong>빌드 진행:</strong> 신규 개발 소스 및 컴파일 결과물 준비, 정상 기능 단위 및 서비스 분류</p>
</li>
<li>
<p><strong>사용자 환경 분석:</strong> 최소 사용자 환경 사전 정의</p>
</li>
<li>
<p><strong>패키징 적용 시험:</strong> 사용자 환경에서의 패키징 적용 시험, UI 및 시스템 상의 편의성 체크</p>
</li>
<li>
<p><strong>패키징 변경 개선:</strong> 패키징 적용 시 변경점 도출, 최소 사용자 환경에서 서비스 가능한 수준의 개선</p>
</li>
</ol>
<h1 id="heading-94"></h1>
<h3 id="애플리케이션-패키징-릴리즈-노트"><strong>애플리케이션 패키징 릴리즈 노트</strong></h3>
<h1 id="heading-95"></h1>
<ul>
<li>
<p><strong>헤더( Header ):</strong> 문서 이름, 제품이름, 버전 번호, 릴리즈 날짜, 참고 날짜, 노트 버전 등</p>
</li>
<li>
<p><strong>개요:</strong> 제품 및 변경에 대한 간략한 전반적 개요</p>
</li>
<li>
<p><strong>목적:</strong> 릴리스 버전의 새로운 기능 목록과 릴리스 노트의 목적에 대한 개요, 버그 수정 및 새로운 기능 기술</p>
</li>
<li>
<p><strong>이슈 요약:</strong> 버그의 간단한 설명 또는 릴리즈 추가 항목 요약</p>
</li>
<li>
<p><strong>재현 항목:</strong> 버그 발견에 따른 재현 단계 기술</p>
</li>
<li>
<p><strong>수정/ 개선 내용</strong>: 수정/ 개선의 간단한 설명 기술</p>
</li>
<li>
<p><strong>사용자 영향도:</strong> 버전 변경에 따른 최종 사용자 기준의 기능 및 응용 프로그램상의 영향도 기술</p>
</li>
<li>
<p><strong>소프트웨어 지원 영향도:</strong> 버전 변경에 따른 소프트웨어의 지원 프로세스 및 영향도 기술</p>
</li>
<li>
<p><strong>노트:</strong> 소프트웨어 및 하드웨어 설치 항목, 제품, 문서를 포함한 업그레이드 항목 메모</p>
</li>
<li>
<p><strong>면책조항:</strong> 회사 및 표준 제품과 관련된 메시지, 프리웨어 및 불법 복제 방지, 중복 등 참조에 대한 고지사항</p>
</li>
<li>
<p><strong>연락정보:</strong> 사용자 지원 및 문의 관련한 연락처 정보</p>
</li>
</ul>
<h1 id="heading-96"></h1>
<h3 id="노트-작성-프로세스"><strong>노트 작성 프로세스</strong></h3>
<ol>
<li>
<p><strong>모듈 식별:</strong> 릴리즈 노트 작성을 위한 빌드 정리</p>
</li>
<li>
<p><strong>릴리즈 정보 확인:</strong> 문서이름, 제품이름 등</p>
</li>
<li>
<p><strong>릴리즈 노트 개요 작성:</strong> 제품 및 변경에 대한 간략한 전반적인 개요 작성</p>
</li>
<li>
<p><strong>영향도 체크</strong>: 버그의 간단한 설명 또는 릴리즈 추가 항목 기술</p>
</li>
<li>
<p><strong>정식 릴리즈 노트 작성:</strong> 릴리즈 정보, 헤더 및 개요 등 기본사항 기술</p>
</li>
<li>
<p><strong>추가 개선 항목 식별:</strong> 추가 개선에 대한 베타 버전을 이용 테스트 수행</p>
</li>
</ol>
<h1 id="heading-97"></h1>
<h3 id="애플리케이션-배포-도구"><strong>애플리케이션 배포 도구</strong></h3>
<h1 id="heading-98"></h1>
<ul>
<li>애플리케이션 배포 도구는 배포를 위한 패키징 시에 디지털 콘텐츠의 지적재산권을 보호하고 관리하는 기능을 제공</li>
</ul>
<h1 id="heading-99"></h1>
<p>ㅁㅇㅁㄴㅇㅇㅁ임낭;ㅣㅁ낭;ㅁ니암ㄴ;ㅣ아ㅣㅁㄴ;암ㄴ안미;암니안ㅁ;ㅣ암ㄴ;암남ㄴ</p>
<h1 id="heading-100"></h1>
<hr>
<hr>
<h2 id="drm-digital-rights-management-"><strong>DRM( Digital Rights Management )</strong></h2>
<h1 id="heading-101"></h1>
<ul>
<li>DRM은 디지털 콘텐츠에 대한 권리정보를 지정하고 암호화 기술을 이용하여 허가된 사용자의 허가된 권한 범위 내에서 콘텐츠의 이용이 가능하도록 통제하는 기술</li>
</ul>
<h1 id="heading-102"></h1>
<h3 id="drm의-특징"><strong>DRM의 특징</strong></h3>
<h1 id="heading-103"></h1>
<ul>
<li>
<p>거래 투명성: 저작권자와 콘텐츠 유통업자 사이의 거래구조 투명성</p>
</li>
<li>
<p>사용규칙 제공: 사용가능 횟수, 유효기간, 사용 환경 등을 정의 가능</p>
</li>
<li>
<p>자유로운 상거래 제공: 이메일, 디지털 미디어, 네트워크 등을 통한 자유로운 상거래 제공</p>
</li>
</ul>
<h1 id="heading-104"></h1>
<h3 id="drm의-구성요소"><strong>DRM의 구성요소</strong></h3>
<h1 id="heading-105"></h1>
<ul>
<li>
<p>콘텐츠 제공자( DRM 콘텐츠, 패키저 ), 클리어링 하우스( 콘텐츠 정책, 콘텐츠 라이센스, 콘텐츠 관리정보, 콘텐츠 사용정보 ), 콘텐츠 소비자( DRM 컨트롤러, 보안 컨트롤러 )</p>
</li>
<li>
<p>DRM의 기술요소</p>
<ul>
<li>접속 제어</li>
<li>사용 제어</li>
<li>내용 제어</li>
</ul>
</li>
</ul>
<h1 id="heading-106"></h1>
<hr>
<hr>
<h2 id="heading-107">**</h2>
</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex justify-between">





</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#데이터-입출력-구현"><strong>데이터 입출력 구현</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#자료-구조--data-structure-"><strong>자료 구조 ( Data Structure )</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#자료-구조의-분류"><strong>자료 구조의 분류</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#리스트의-종류"><strong>리스트의 종류</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#스택--stack-"><strong>스택 ( Stack )</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#큐--queue-"><strong>큐 ( Queue )</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#데크--deque-double-ended-queue-"><strong>데크 ( Deque: Double Ended Queue )</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#트리-tree"><strong>트리 Tree</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#트리-순회-방법"><strong>트리 순회 방법</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#이진-트리"><strong>이진 트리</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#그래프--graph-"><strong>그래프 ( Graph )</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#논리-데이터-저장소"><strong>논리 데이터 저장소</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#논리-데이터-저장소-검증-절차"><strong>논리 데이터 저장소 검증 절차</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#물리-데이터-저장소"><strong>물리 데이터 저장소</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#물리-데이터-저장소-모델-변환-절차"><strong>물리 데이터 저장소 모델 변환 절차</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#물리-데이터-저장소-구성"><strong>물리 데이터 저장소 구성</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#테이블-제약조건--constraint-설계"><strong>테이블 제약조건 ( Constraint )설계</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#인덱스--index--설계"><strong>인덱스 ( Index ) 설계</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#뷰-view--설계"><strong>뷰( View ) 설계</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#클러스터-cluster--설계"><strong>클러스터( Cluster ) 설계</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#파티션-partition--설계"><strong>파티션( Partition ) 설계</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#디스크-disk-구성-설계"><strong>디스크( Disk )구성 설계</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#orm-object-relational-mapping-프레임워크"><strong>ORM( Object-Relational Mapping )프레임워크</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#orm-프레임워크-매핑-기법"><strong>ORM 프레임워크 매핑 기법</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#orm-프레임워크-매핑-기법-1"><strong>ORM 프레임워크 매핑 기법</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#orm-프레임워크-절차"><strong>ORM 프레임워크 절차</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#논리-데이터-저장소-구조"><strong>논리 데이터 저장소 구조</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#트랜잭션-인터페이스"><strong>트랜잭션 인터페이스</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#트랜잭션-인터페이스-설계"><strong>트랜잭션 인터페이스 설계</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#프로시저"><strong>프로시저</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#절차형-데이터-조작-프로시저"><strong>절차형 데이터 조작 프로시저</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#프로그램-디버깅-program-debugging-"><strong>프로그램 디버깅( Program Debugging )</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#프로그램-디버깅-도구"><strong>프로그램 디버깅 도구</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#단위-테스트-도구"><strong>단위 테스트 도구</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#쿼리-query--성능-측정"><strong>쿼리( Query ) 성능 측정</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#sql-성능-개선-절차"><strong>SQL 성능 개선 절차</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#소스-코드-인스펙션-source-code-inspection-"><strong>소스 코드 인스펙션( Source Code Inspection )</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#sql-코드-인스펙션-대상"><strong>SQL 코드 인스펙션 대상</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#sql-코드-인스펙션-절차"><strong>SQL 코드 인스펙션 절차</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#모듈-구현"><strong>모듈 구현</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#단위-모듈-테스트"><strong>단위 모듈 테스트</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#테스트-커버리지"><strong>테스트 커버리지</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#ide-도구"><strong>IDE 도구</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#ide-intergrated-development-environment-"><strong>IDE( Intergrated Development Environment )</strong></a></li>
        <li><a href="#ide-도구의-기능"><strong>IDE 도구의 기능</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#협업-도구"><strong>협업 도구</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#협업-도구의-분류"><strong>협업 도구의 분류</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#형상-관리-도구"><strong>형상 관리 도구</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#형상-관리-도구의-기능"><strong>형상 관리 도구의 기능</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#형상-관리-도구의-사례"><strong>형상 관리 도구의 사례</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#애플리케이션-패키징-application-packaging-"><strong>애플리케이션 패키징( Application Packaging )</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#사용자-관점에서의-패키징-고려사항"><strong>사용자 관점에서의 패키징 고려사항</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#애플리케이션-패키징-프로세스"><strong>애플리케이션 패키징 프로세스</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#애플리케이션-패키징-릴리즈-노트"><strong>애플리케이션 패키징 릴리즈 노트</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#노트-작성-프로세스"><strong>노트 작성 프로세스</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#애플리케이션-배포-도구"><strong>애플리케이션 배포 도구</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#drm-digital-rights-management-"><strong>DRM( Digital Rights Management )</strong></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#drm의-특징"><strong>DRM의 특징</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#drm의-구성요소"><strong>DRM의 구성요소</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#heading-107">**</a></li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>
</div>
</html>















