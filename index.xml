<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on 왈왈왈</title>
    <link>https://mung0001.github.io/</link>
    <description>Recent content in Home on 왈왈왈</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 02 Apr 2014 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://mung0001.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/cloud/aws/aws_computing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/cloud/aws/aws_computing/</guid>
      <description>AWS 컴퓨팅 서비스   EC2 ( Elastic Compute Cloud )  EC2 공식 홈페이지 가상 컴퓨팅 서비스를 제공해주는 서버로 실제 물리서버와 똑같은 형태의 서비스를 제공 AMI를 통해 필요한 운영체제와 여러 소프트웨어를 쉽게 생성 가능 키 페어를 사용하여 로그린 정보 보호 SSH로 원격 연결이 가능 중지가 가능한 EBS 기반 인스턴스와 임시 스토리지를 제공하여 중지가 불가능한 Instance Store 기반 EC2로 분류 됨 ( 재부팅은 모두 가능 ) 인스턴스의 유형으로는 범용, 컴퓨팅 최적화, 메모리 최적화, 스토리지 최적화 등이 존재   EC2 상태의 종류  Pending : 인스턴스가 구동하기 위해 준비중인 상태, 요금 미청구 Runnung : 인스턴스가 실행하고 사용할 준비가 된 상태, 요금 청구 Stopping : 인스턴스가 중지 모드로 전환되려는 상태, 요금 미청구 Shutting-down : 인스턴스가 종료를 위해 준비중인 상태, 요금 미청구 Terminated : 인스턴스가 종료된 상태, 요금 미청구   EC2 구매옵션  On demand : 필요할 때 바로 생성하는 방식으로 1시간 단위로 과금이 이루어짐 ( 1분 사용시도 1시간 ) Spot : 경매방식의 인스턴스 기준가격보다 높은 가격 제시시 사용가능하며, 타인에 의해 불시로 종료되거나 정지될 수 있어 각종 테스트에 적합 Reserved : 12개월- 36개월 단위로 예약하여 사용하는 인스턴스로 On demandq비해 가격이 대폭 할인되며, 장기적으로 사용할 경우 효율이 좋지만, 예약된 인스턴스이기에 사용하지 않아도 과금이 부과되어짐    Lightsail  Lightsail Site AWS에서 VPS ( Virtual Private Server : 가상 사설 서버 ) 를 시작하는 가장 쉽고 빠른 방법 가상 사설 서버, 영구적인 스토리지, 네트워킹을 포함 클릭 한 번으로 모든 과정을 생략, 쉽게 VPS를 생성 및 관리 확장가능 및 타 AWS Services에 접근 가능 고가용성 어플리케이션 생성 가능 저렴하고, 비용의 예측이 보다 쉬움 완전히 사전구성되어 있는 서버 ( BluePrint )   Lightsail의 유료 Plan  월간 무료 데이터 허용량 초과시, 퍼블릭 IP 주소를 사용ㅎ여 요금 청구 Lightsail 스냅샷 비용 : 인스턴스 스냅샷 + 디스크 스냅샷 1시간 이상 인스턴스에 연결되어 있지 않은 고정 IP ( Elastic IP ) 무료로 주어지는 3백만 개의 쿼리를 초과하는 경우   Lightsail&amp;amp; EC2  Lightsail의 주 사용용도  웹 사이트 및 블로그 단순 앱 개발 및 테스트 환경 소수의 서버로 구성된 비즈니스 소프트웨어   EC2  빅데이터 분석 고성능 컴퓨팅 과학 분야 컴퓨팅 멀티&#39;티어 애플리케이션      ECS ( Elastic Container Service )  AWS의 Virtual Machine, VM (가상 머신) 가상의 컴퓨터, 하나의 호스트에 안에 또다른 호스트를 만들어 사용하는 것 CPU, Memory와 같은 주요 하드웨어 부품을 소프트웨어로 완전 재현해내어 기능을 흉내내게 하고(에뮬레이션), 격리된 실행 환경(OS)를 만듬 즉 하드웨어를 직접 가상화 클러스터에서 도커 컨테이너를 손쉽게 관리하기 위해 컨테이너 관리 서비스 클러스터는 Task(작업) 또는 서비스로 일컬어지는 컨테이너들의 집합 2가지 구성 요소로 시작 가능  EC2(Container Instance) : EC2를 생성하여 EC2 내에 Task(컨테이너가 수행할 작업) Fargate : EC2를 생성하거나 컨테이너를 실행하기 위한 Orchestration을 AWS가 맡아 하는 서비스로, 관리가 용이함   하나의 클러스터 내에 다수의 Task 혹은 컨테이너 인스턴스로 구성됨 또한 ELB, EBS 볼륨, VPC, IAM과 같은 기능을 사용하여 구성 가능 즉 ECS 각 작업의 권한, ECS 액세스를 IAM으로 조절하거나, EC2 유형의 컨테이너 인스턴스만이 OS에 액세스 가능한 특징 등을 갖게 됨 호스트의 OS(Operating System) 내에 또다른 실행환경의 OS가 존재함 윈도우 OS의 호스트 내에 리눅스, 우분투 등의 다양한 OS를 올릴 수 있음 다만 OS를 포함하기 때문에 용량을 많이 차지할 뿐더러, 사용자가 필요치 않는 기능까지 포함할 수 있으며 느림   Linux Container  ECS를 사용하는 목적이자 관리 대상 하드웨어가 아닌 OS를 가상화하여 커널을 공유하며 프로세스(컨테이너와 비슷)를 격리된 환경에서 실행하는 것 VM와 달리 달리 호스트의 OS에서 가상화를 실시하여, 이 OS 위에 프로세스들이 ‘컨테이너’로서 격리된 환경에서 실행됨 호스트의 입장에선 컨테이너는 프로세스에 불과하지만, 컨테이너 입장에서는 독립된 실행환경임 OS를 포함하지 않는만큼 가볍고, 하드웨어를 가상화하지 않기 때문에 빠름   Kernel  Operaintg System에서 가장 중요한 역할을 맡고 있는 핵심(核心) 커널이 각 프로세스(실행환경)에 하드웨어 자원(CPU 등)을 할당하고, 작업 스케쥴링(처리순서)를 담당하며, 프로세스 간 접근과 보안을 책임짐 과거에 커널이 없던 시절에도 컴퓨터는 존재할 수 있었으나 메모리를 초기화하기 위해서는 컴퓨터를 리부팅해야 하는 등, 자원관리/제어 주체의 필요성에 의해 탄생   Docker  앞서 설명한 Linux Container 기술에 근간을 두는 오픈소스 컨테이너 프로젝트 ‘Docker’라는 단어 자체가 ‘부두에서 일하는 노동자’, 즉 컨테이너를 관리하는 존재임을 뜻함 Linux Container 기술을 사용하는 솔루션이므로 별도의 OS를 설치하지 않고 컨테이너를 생성하여 애플리케이션을 실행함 컨테이너를 생성할 이미지(서비스에 필요한 리소스를 모아둔 최소한의 단위)를 기반으로 운영함 이미지만 가지고 있다면 어느 시점에서든 동일한 리소스의 컨테이너를 생성할 수 있음 그 밖에 컨테이너간의 연결, 다양한 API 제공 등의 기능을 보유    Lambda  Serverless Service 서버를 구축, 프로비져닝하고 필요한 패키지를 설치하는 등의 과정을 거치지 않고, 코드를 실행하는 서비스 사용자는 애플리케이션이나 백엔드 서비스를 관리할 필요 없이 코드를 실행할 수 있음 CloudWatch, ALB, DynamoDB 등을 트리거로 이용하여 특정 상황에서 코드를 실행시키고 것이 가능 API Gateway와 Lambda를 조합하여 요청별로 특정 코드를 수행하도록 구성 가능 15분을 초과하는 작업에 대해서는 Lambda 비적합   Lamda Function의 정의와 구성  코드를 실행하기 위해 호출할 수 있는 리소스 이벤트를 처리하는 코드, 계층, 트리거, 전달 대상 등으로 구성됨  함수코드 : 실제 호출되기 실행되는 코드, Runtime(코드 실행지원), IAM, VPC, Memory 등으로 구성됨 트리거 : 함수코드를 발동시키는 서비스(S3, SNS, SQS, DynamoDB, CloudWatch Event, Cloudwatch Log 등)   SNS의 메시지 구독 대상에 Lambda를 포함시키면, 메시지 발송시 Lambda가 이를 전달받고 함수코드 실행  전달대상 : 함수가 비동기식으로 호출되거나, 레코드를 처리한 경우 전달될 대상   SNS, SQS, 또다른 Lambda, EventBridge 이벤트 버스로 전달가능 NS로부터 메시지를 전달받아 코드를 처리하고 이를 SQS로 보내 메시지 대기열에 적재할 수 있음   EC2 vs Lambda  EC2 사용시 프로비져닝, 운영 체제, 네트워크 세부 설정, 보안 설정 등을 사용자가 원하는 방향으로 지정 가능 Lambda 사용시 프로비져닝 필요없이 AWS가 모니터링, 프로비져닝, 보안패치 적용, 코드 배포를 모두 수행함    Batch Batch Group  클러스터 : 인스턴스를 AZ 내에서 근접하게 배치, 결합된 노드 간 낮은 지연 시간의 네트워크 달성 가능 파티션: 인스턴스가 담긴 그룹을 논리 세그먼트로 나누어 각 파티션에 배치, 최대 7개의 파티션을 가질 수 있으며, 각 파티션은 자체 랙 세트를 보유하고 자체 네트워크 전원을 보유 분산: 파티션이 논리 세그먼트로 분리된 인스턴스 그룹인 것과 달리 분산은 인스턴스 개체 하나가 자체 랙에 분산 배치됨, AZ당 최대 7개의 인스턴스 배치 가능    Elastic Beanstalk </description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/openstack/openstack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/openstack/openstack/</guid>
      <description>인프라 환경 변화의 시작, 클라우드   클라우드 컴퓨팅의 정의와 종류  클라우드 컴퓨팅(Cloud Computing)   인터넷이 가능한 디바이스(스마트폰, 스마트패드, 스마트TV 등)로 클라우드에서 데이터를 처리하며, 저장 및 관리하는 컴퓨팅 시스템
  클라우드 서비스의 종류
  IaaS(Infrastrcture as a Service): 서버, 스토리지, 네트워크를 가상화 환경으로 만 들어 필요에 따라 인프라 자원을 제공하는 서비스
  PaaS(Platform as a Service): 웹에서 개발 플랫폼을 제공하는 서비스
  SaaS(Software as a Service): 온디맨드 소프트웨어(On-demand Software)라고도 하며, 중앙에서 호스팅 되는 소프트웨어를 웹 브라우저 등 클라우이언트로 이용하는 서비스</description>
    </item>
    
    <item>
      <title>Home</title>
      <link>https://mung0001.github.io/docs/study/security/%EC%A0%95%EB%A6%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/security/%EC%A0%95%EB%A6%AC/</guid>
      <description>인
 용
 구
      1 2 3     표 쓸때는 중간 두번째줄에 --- 이거 필요합니다.          이탤릭 , 이탤릭
볼드 볼드
이탤릭볼드
이탤릭볼드
이렇게 할수도
취소선
이건데 .. *이렇게*
😍
https://steemit.com/steemkr-guide/@snow-airline/steemkr-quick-start-guide
@Link, #Link?
#이미지 넣기 ? + 컨트롤 z = 자동 주석처리
# = 강조 ## 두개 = 목차 달기 별 두개 = 강조</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/cloud/aws/aws_migrate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/cloud/aws/aws_migrate/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/cloud/aws/aws_developer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/cloud/aws/aws_developer/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/cloud/aws/aws_management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/cloud/aws/aws_management/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/cloud/aws/aws_analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/cloud/aws/aws_analysis/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/openstack/keystone/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/openstack/keystone/</guid>
      <description>keystone   인증을 관리하는 Keystone   인증 서비스인 Keystone은 인증 토큰을 비롯해 테넌트 및 사용자 관리, 서비스의 엔드포인트 URL 등을 관리하는 기본 서비스
논리 아키텍처의 Keystone  논리 아키텍처에서 Keystone은 Keystone-all, Database와 LDAP로 구성 Keystone-all에는 토큰(Token), 카탈로그(Catalog), 정책(Poliy), 인증(Identity) 등이 포함되어 있음  Token Backend는 사용자별 토큰을 관리 Catalog Backend는 오픈스택에서 모든 서비스의 엔드포인트 URL을 관리 Policy Backend는 테넌트, 사용자 계정, 롤 등을 관리 Identity Backend로 사용자 인증을 관리    오픈스택에서 Keystone 위치  오픈스택 Keystone은 모든 서비스를 관장하는 위치이 있음 Keystone은 타인이나 해커에게서 시스템을 안전하게 보호하고 사용자 등록, 삭제, 권한 관리, 사용자가 접근할 수 있는 서비스 포인트 관리까지 전반적인 사용자 인증을 관리  도메인, 프로젝트, 그룹, 사용자, 롤의 개념과 관계  Keystone은 사용자 인증 부분과 서비스 인증 부분을 관리함 사용자일 때는 사용자 ID와 패스워드, 사용자 권한의 롤(Roll)을 등록 서비스일 때는 서비스를 등록하고 해당 서비스의 엔드포인트 URL을 등록  도메인(Domain)은 서로 분리되어 있음 각 도메인에는 프로젝트와 사용자가 있음 프로젝트는 사용자를 가질 수 있음 사용자에게는 롤이 있으며, 여러 프로젝트의 구성원이 될 수 있음 관리자 롤(Admin Role)을 가진 사용자끼리, 일반 사용자롤(Member Role)을 가진 사용자끼리 그룹핑(Grouping)을 할 수 있음    Keystone의 속성비교  회사의 Keystone은 도메인에 해당 관리자와 일반 사용자는 Keystone의 프로젝트에 해당 시스템을 잘 개발하는 직원은 관리자이면서 사용자에 해당 관리자가 시스템을 이용해 할 수 있는 역할은 롤에 해당 메뉴는 서비스에 해당하며, 메뉴에 연결할 링크는 엔드포인트 URL에 해당    </description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/openstack/glance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/openstack/glance/</guid>
      <description>Glance   운영체제 이미지를 관리하는 Glance  이미지 서비스인 Glance는 Nova에서 생성하는 인스턴스의 운영체제에 해당하는 이미지를 관리 가상머신을 생성해 컴퓨터를 대신 사용, 이 때 필요한 운영체제의 이미지 파일을 Glance이 다양한 하이퍼바이저에서 사용할 수 있는 VM 이미지를 관리 및 VM에 설치된 운영체제를 보관, 관리 함  논리 아키텍처의 Glance   Glance 사용자들은 glance-api로 이미지를 등록, 삭제, 관리할 수 있음
  glance-api는 glance-registry와 Glance database에서 이미지를 관리함
  이미지를 등록할 때는 glance-registry로 Glance database에 저장됨</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/openstack/nova/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/openstack/nova/</guid>
      <description>Nova   가상 서버를 생성하는 컴퓨트 Nova   오픈 스택 Nova는 컴퓨트 서비스의 핵심이며, 하이퍼바이저, 메시지 Queue, 인스턴스 접속을 하는 콘솔 등의 다양한 기능이 유기적으로 연결되어 가상 서버를 생성할 수 있는 시스템을 구성
논리 아키텍처 Nova  Nova는 대시보드나 콘솔에서 호출하는 nova-api에서 시작 Queue를 이용해 nova-compute에 인스턴스를 생성하라는 명령을 전달 nova-compute는 하이퍼바이저 라이브러리를 이용해 하이퍼바이저에 인스턴스를 생성하려는 명령어를 전달 하이퍼바이저가 인스턴스를 생성 생성된 인스턴스는 nova-api로 접근할 수 있으며 Nova의 몯느 기능은 메시지 Queue로 처리할 수 있음  Nova가 지원하는 하이퍼바이저의 종류  기본 하이퍼바이저는 KVM과 QEMU 프로바이더가 테스트하는 Hyper-V, VMware, XenServer, Sen via libvirt 몇 번의 테스트만 하는 하이퍼바이저 드라이버인 베어메탈, Docker, LXC via libvirt  노드별로 설치되는 Nova  nova-api: Nova의 REST API 서버를 담당 nova-cert: X509 인증서 서비스를 제공하는 서버 데이터 데몬 nova-conductor: 코디네이션과 데이터베이스 쿼리를 지원하는 서버 데몬 nova-consoleauth: nova-console 인증을 제공 nova-novncproxy: novnc-console과 호환되는 웹 소켓 프록시 nova-scheduler: VM 인스턴스를 실행할 컴퓨터 노드를 선택하는 역할을 수행 nova-novaclient: nova REST API를 사용하는 클라이언트 프로그램 컴퓨터 노드에 설치  nova-compute-kvm: 인스턴스(가상 머신)와 관련된 모든 프로세스를 처리 python-guestfs: 파일 생성 기능을 지원하는 Python 라이브러리 qemu-kvm: KVM 하이퍼바이저      </description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/openstack/swift/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/openstack/swift/</guid>
      <description>Swift   오브젝트 스토리지 Swift   다른 서비스와는 다르게 단독으로 구성되며, 클라우드 스토리지 서비스를 구축 할 수 있음
논리 아키텍처의 Swift  오픈스택 Swift는 swift-proxy-server, swift-account-server, swift-container-server, swift-object-server로 구성 swift-proxy-server는 swift-account-server, swift-container-server, swift-object-server를 관리 어카운트, 컨테이너는 별도의 메타데이터가 데이터베이스로 관리됨 오브젝트는 저장 공간에 직접 저장되는 방식으로 설계되어 있음 swift-proxy-server는 오픈스택의 Object API를 제공 사용자는 API를 사용해 데이터를 저장하거나 내려받을 수 있음  Swift의 논리적 구성 요소  Swift의 구성은 스토리지 공간 여러 개를 합쳐 하나의 커다란 공간으로 가상화하고, 그 안에서 사용자만의 별도 스토리지 공간이 있는 것처럼 다시 가상화를 진행 사용자는 특성에 따라 데이터를 분류해서 저장할 컨테이너를 생성하고 해당 컨테이너에 데이터를 저장 swift-proxy-server는 스토리지 노드 여러 개를 관리하며 사용자 인증을 담당, 최근에는 Keystone으로 인증을 처리하며, 프록시 서버와 함께 설치되기도 함 스토리지 노드에는 swift-account-server, swift,compute-server, swift-object-server가 실행되며 실제 메타데이터파일이나 오브젝트에 해당하는 데이터 파일을 저장  Swift의 특징  인증: 사용자의 인증을 담당하는 기능 어카운트(Account): 사용자 계정 및 컨테이너를 관리 컨테이너: 저장 공간 단위로 컨테이너 안의 오브젝트 정보를 관리 오브젝트: 실제 데이터  Swift Ring  Swift 역시도 Nova를 구성할 떄와 마찬가지로 스토리지 노드가 여러 대 있음 각 스토리지 노드에는 swift-account-server, swift-container-server, swift-object-server가 실행됨 서버들은 관리자가 설정한 해당 포트로 서로 통신 스토리지 노드 중 하나라도 손상이 되면 데이터를 잃지 않도록 데이터 복제(Replica)프로세스가 함께 실행됨 스토리지 파일은 자신이 관리하는 데이터를 서로 공유하려고 Ring인 파일이 어느 노드에, 어떤 데이터가 들어 있는 지를 인지함 Ring파일은 프록시 노드에서 생성해 모든 스토리지 노드가 동일하게 가지고 있음 Ring 파일에는 디바이스 정보가 들어 있는데,  디바이스를 구분하는 ID 존(Zone) 번호 스토리지 노드 IP 포트 디바이스 이름 디바이스 비중 기타 디바이스 정보    Swift의 데이터 관리 방법  Swift는 사용자 게정을 관리하는 어카운트, 디렉터리 개념의 컨테이너, 실제 파일을 표현하는 오브젝트로 구성 Swift는 어카운트가 컨테이너를 포함하고, 컨테이너가 오브젝트를 포함하도록 관리함 보통 Swift에서는 프록시 노드 한 대에 스토리지 노드 다섯 대를 구성하기를 권장 프록시 노드들은 로드밸런서로 묶여 있어 사용자는 특정 URL 하나만 호출해도 스토리지 서비스를 자유롭게 사용가능 파일을 올릴 때는 설정된 리플리카로 여러 스토리지 노드로 분산해서 저장, 다운로드 시 그 중 한 곳을 사용  Swift와 Keystone  Swift에는 SwAuth를 이용하는 인증 방법과 Keystone을 이용하는 인증 방법이 있음 최근에는 Keystone을 이용해서 주로 인증하며, Keystone에는 프로젝트, 사용자, 롤이 있음 관리자(admin, swiftoperator)는 사용자와 컨테이너를 생성, 삭제할 수 있음 관리자는 오브젝트도 올리기, 내려받기, 삭제를 할 수 있음 일반 사용자(member)은 사용자와 컨테이너를 생성할 수 없음 일반 사용자는 관리자가 미리 생성해서 권한을 준 컨테이너만 사용할 수 있음 일반 사용자는 관리자가 설정한 권한으로 오브젝트 목록을 확인할 수 있음 일반 사용자는 관리자가 설장한 권한으로 데이터를 올리고 내릴 수 있음 특정 사용자에게 관리자(admin) 권한을 부여하려면 리셀러어드민(ResellerAdmin) 롤을 주어야 함 해당 사용자는 관리자가 할 수 있는 기능을 모두 사용할 수 있음  Swift의 이레이저 코딩(Eraure Coding) 기능과 스토리지 정책   스토리지 저장 공간을 효율적으로 관리하는 것이 이레이져 코딩</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/openstack/neutron/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/openstack/neutron/</guid>
      <description>Neutron   네트워크를 관리하는 Neutron   폴섬 버전에서는 Quantum, 그리즐리 버전에서는 Neutron으로 릴리스 되었음
  기존 오픈스택의 네트워크 서비스는 nova-network가 담당했으나, SDN(Software Defined Network) 개념이 들어오면서 별도의 네트워크 프로젝트로 분리되었음
논리 아키텍처의 Neutron  Neutron은 neutron-server, Neutron L2 Agent* 및 neutron-l3-agent*, neutron-dhcp-agent, Queue, Neutron Database, Neutron 3rd Party Plugin으로 구성 Neutron은 다양한 네트워크 플러그인이나 네트워크 모델을 지원  사용자는 Neutron API를 이용해 neutron-server로 IP 할당을 요청 neutron-server 들어온 요청을 Queue로 다시 요청 Queue는 neutron-dhcp-agent와 Neutron 3rd Party plugin으로 IP 할당 지시를 내림 neutron-dhcp-agent와 Neutron 3rd Party Plugin은 지시 받은 작업 수행을 시작 neutron-server는 수시로 작업 상태를 Neutron database에 저장 할당된 IP를 인스턴스에서 사용 가능    Neutron이 지원하는 플러그인의 종류  사이트 참조  Neutron과 VRRP, DVR  VRRP(Virtual Router Redundancy Protocl)로 랜에서 정적으로 설정된 기본 라우터를 사용할 때, 하나 이상의 백업 라우터를 사용하는 방법을 제공하는 인터넷 프로토콜 DVR(Distributed Virtual Router)이란 VRRP 기능을 향상시키고, 분산 라우팅 기능과 HA(High Availability), 로드밸런싱 기능을 사용할 수 있음 기존 레거시 HA 라우터와 마찬가지로 DVR/ SNAT(Static NAT), HA 라우터는 다른 노드에서 실행되는 L3 Agent의 백업 DVR/ SNAT 라우터에서 SNAT 서비스 장애를 빠르게 해결 가능 #    </description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/openstack/cinder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/openstack/cinder/</guid>
      <description>Cinder   블록 스토리지를 관리하는 Cinder   Nova에서 생성된 인스턴스에서 확장해서 사용할 수 있는 저장 공간을 생성, 삭제하고 인스턴스에 연결 할 수 있는 기능을 제공
논리 아키텍처의 Cinder  논리 아키텍처의 Cinder은 cinder-api, Queue, Cinder Database, cinder-volume, Volume Provider, cinder-scheduler로 구성되어짐 아키텍처의 특징  cinder-api로 볼륨을 추가, 삭제할 수 있음 cinder-volume은 볼륨을 실제서 생성 및 Cinder Database에 볼륨 정보를 업데이트 Cinder는 물리 하드 디스크를 LVM(Logical Volume Manager)으로 설정 설정된 LVM은 cinder-conf와 nova.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/openstack/horizon/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/openstack/horizon/</guid>
      <description>Horizon   대시보드 Horizon   사용자가 웹 UI로 인스턴스 생성, 삭제, 관리 등을 쉽고 빠르게 처리할 수 있게 지원
  Horizon은 아파치 웹 서버를 사용 및 Python, Django 프레임워크로 구현되어 있음
논리 아키텍처의 Horizon  논리 아키텍처에서 보이는 Horizon은 단순히 Horizon 자체 모듈만 있음 모든 서비스의 API와 연동해서 사용자에게 웹 서비스를 제공 할 수 있음    </description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/openstack/ceilometer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/openstack/ceilometer/</guid>
      <description>텔레미터 서비스 Ceilometer   텔레미터 서비스 Ceilometer  클라우드에서 배포된 자원의 사용량과 성능을 측정해 사용자가 자원 상태를 모니터링 할 수 있는 기능을 제공 Ceilometer는 다음 요소로 구성됨  ceilometer-colletcor: 중앙 관리 서버에서 실행되며, 메시지 Queue(에이전트에서 오는 미터링 데이터 알림)을 모니터링 할 수 있음 ceilometer-agent-notification: ceilometer-collector와 함꼐 중앙 관리서베에서 실행, 메시지 Queue를 이용해 이벤트와 미러링 데이터를 기록 ceilometer-agent-compute: 각 컴퓨팅 노드에 설치해서 실행, 자원 활용 통계로 사용 ceilometer-account-central: 중앙 관리 서버에서 실행, 인스턴스에 연결되지 않은 자원이나 컴퓨터 노드의 활용 가능한 자원 통계를 폴링 ceilometer-alarm-evaluator: 하나 이상의 중앙 관리 서버에서 실행, 슬라이딩 시간대에 임계 값을 추가할 때 발생하는 경보 시점을 결정 ceilometer-alarm-nottifier: 하나 이상의 중앙 관리 서버에서 실행되며, 샘플을 수집하는 임계 값 평가에 따라 알람을 설정 할 수 있음 ceilometer database: 수집한 데이터를 저장할 Ceilometer 데이터 베이스 ceilometer-api: 하나 또는 그 이상의 중앙 관리 서버에서 실행되며 데이터베이스에서 데이터 엑세스를 제공 Ceilometer는 리버티 버전에서 기존에 알람 서비스를 하던 부분을 aodh로 분리, 알람서비스를 위해서는 별도로 aodh를 설치해야 됨    </description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/openstack/heat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/openstack/heat/</guid>
      <description>Heat   오케스트레이션 서비스 Heat  오케스트레이션은 자원 관리, 배치, 정렬을 자동화하는 것 오케스트레이션은 인스턴스 생성에 대한 일련의 과정을 자동화해서 인프라를 쉽게 배포할 수 있도록 하는 탬플릿 기반 엔진 오케스트레이션에서 사용되는 템플릿 언어는 인프라, 서비스, 응용프로그램, 프로비저닝, 자동화 컴퓨팅, 스토리지, 네트워킹, 자동 스케일링 등에 사용 가능 Heat는 다음 요소로 구성  Heat: Heat 도그는 AWS CloudFormation API와 Heat API가 서로 커뮤니케이션 할 수 있는 CLI heat-api: RPC heat 엔진에 전송해서 요청된 API를 처리한 REST API를 제공 heat-api-cfn: AWS CloudFormation과 호환되는 AWS 타입의 Query API를 제공 heat-engine: 템플릿을 생성하고, Consumer(API를 사용하려고 접근하는 애플리케이션이나 서비스)를 다시 이벤트로 제공하는 오케스트레이션의 주 작업을 수행    </description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/programing/code/java/java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/programing/code/java/java/</guid>
      <description>Java ****  ...</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/programing/code/php/php/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/programing/code/php/php/</guid>
      <description>PHP ID, PW EX...&amp;lt;?php$cookie=$_GET[&amp;#34;data&amp;#34;];$myfile=fopen(&amp;#34;cookie/data.txt&amp;#34;, &amp;#34;a+&amp;#34;);fwrite($myfile, $cookie.&amp;#34;\r\n&amp;#34;);fclose($myfile);?&amp;gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/openstack/trove/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/openstack/trove/</guid>
      <description>Trove   데이터베이스 서비스 Trove  관계형 데이터베이스 기능을 활용가능, 클라우드 사용자와 데이터 베이스 관리자는 필요에 따라 Trove를 통해 데이터베이스 인스턴스를 제공, 관리가 가능 Trove는 다음 요소로 구성  python-troveclient: 클라이언트에서 콘솔로 trove-api를 실행할 수 있게 지원 trove-api: RESTful API 방식의 JSON을 지원, Trove인스턴스를 관리하고 프로비저닝 trove-taskmanager: 인스턴스 프로비저닝을 지원, 라이프 사이클 관리 및 운영하는 작업을 수행 trove-conductor: 호스트에서 실행되는 서비스로 호스트 정보를 업데이트 및 게스트 인스턴스 메시지를 수신 trove-guestagent: 게스트 인스턴스 안에서 실행, 데이터 베이스 작업을 실행, 관리    </description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/openstack/sahara/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/openstack/sahara/</guid>
      <description>Sahara   데이터 프로세싱 서비스 Sahara  오픈스택 위 빅데이터를 다루기 위한 Hadoop이나 Spark를 쉽게 제공할 수 있게 도와주는 서비스 Sahara는 다음 요소로 구성  Auth: 클라이언트 인증 및 권한을 부여, 오픈스택 인증 서비스 Keystone과 통신 DAL: Data Access Layer의 약어로 데이터 엑세스 계층을 의미, DB의 내부 모델을 유지 Secure Storage Access Layer: 암호 및 개인 키 같은 인증 데이터를 안전한 저장소에 보관 Provisioning Engine: 오픈스택 컴퓨트 서비스 Nova, Heat, Cinder, Glance, Designate와 통신을 담당하는 구성 요소 Vendor Plugins: 프로비저닝된 VM에서 데이터 처리 프레임워크를 구성하고 시작하는 기능을 담당하는 플러그 가능한 메커니즘 EDP: Elastic Data Processing의 약어로 Sahara가 제공하는 클러스테에서 데이터 처리 작업을 예약하고 관리 REST API: REST HTTP 인터페이스로 Sahara 기능을 호출 Python Sahara Client: 다른 오픈스택 구성 요소와 마찬가지로 Sahara에는 자체 Python 클라이언트가 있음 Sahara Pages: Sahara용 GUI로 오픈스택 대시보드인 Horizon에 있음    </description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/openstack/ironic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/openstack/ironic/</guid>
      <description>Ironic   베어메탈 서비스 Ironic   물리적인 컴퓨터를 관리하고 자원을 제공하는 구성요소의 모음
  Ironic은 구성에 따라 다음과 같은 다른 여러 오픈스택 서비스와 상호 작용할 수 있음
 IPMI 메트릭을 사용하는 오픈스택 텔레미터 모듈(Ceilometer) 인증 요청 및 다른 오픈스택 서비스를 인증하는 오픈스택 인증 서비스(Keystone) 이미지 및 이미지 메타데이터를 검색할 수 있는 오픈스택 이미지 서비스(Glance) DHCP 및 네트워크를 구성하는 오픈스택 네트워크 서비스(Neutron) 오픈스택 네트워크 서비스인 Nova는 베어메탈 서비스와 함꼐 작동하고, 인스턴스를 관리하는 사용자용 API를 제공 오픈스택 컴퓨트 서비스는 베어메탈 서비스가 제공하지 않는 예약 기능, 테넌트 할당량, IP 할당, 기타 서비스를 제공 오픈스택 오브젝트 스토리지 서비스인 Swift는 드라이브 설정, 사용자 이미지, 배포 로그 및 점검 데이터 임시 저장 장소를 제공    Ironic은 다음 요소로 구성</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/openstack/service/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/openstack/service/</guid>
      <description>****   옵셔널 서비스  컴퓨트, 오브젝트 스토리지, 이미지, 인증, 네트워크, 블록 스토리지, 대시보드 서비스만으로도 오픈스택을 구축할 수 있음 텔레미터, 오케스트레이션, 데이터베이스 같은 서비스를 제대로 사용한다면 효율적인 클라우드 관리와 운영에 많은 도움을 많을 수 있음 메시징 서비스 Zaqar 공유 파일 시스템 서비스 Manila DNS 서비스 Designate  </description>
    </item>
    
    <item>
      <title>테스트</title>
      <link>https://mung0001.github.io/posts/goisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/posts/goisforlovers/</guid>
      <description>Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.
This document is a brief primer on using Go templates.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/cloud/aws/auto-scaling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/cloud/aws/auto-scaling/</guid>
      <description>Auto Scaling  Auto Scaling  EC2 인스턴스를 자동으로 시작하거나 종료하여 애플리케이션 로드를 처리하기에 적절한 수의 EC를 유지할 수 있도록 하는 서비스 사용자가 정의하는 조건에 따라 EC2 개수를 자동으로 확장 또는 축소가 가능 모니터링을 통해 비정상 인스턴스를 탐지하고 교체할 수 있음 수요가 급증할 경우 EC2 수를 자동으로 늘려 성능을 유지하고 수요가 적을 경우 수를 줄여 비용을 절감 ELB의 대상그룹을 Auto Scaling Group( ASG )에 포함시켜 자동생성된 EC2로 하여금 트래픽 부하분산을 하도록 설정가능 수요 변화가 예측 나응한 경우 예약된 일정을 통해 정해싲 시간에 늘리거나 줄이도록 설정이 가능 ASG 내 손상된 인스턴스가 발견될 경우, Auto Scaling은 이를 자동으로 종료하고 새로운 인스턴스로 교체  ELB를 사용하는 경우, ELB가 손상된 인스턴스를 트래픽 요청 대상에서 분리시킨 후, Auto Scaling이 이를 새로운 인스턴스로 교체   비정상 서버 탐지 후 Auto Scaling이 새로운 인스턴스를 In Service 상태를 만들기까지 5분 이내 소요   AWS Auto Scaling 그룹.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/cloud/aws/aws-%EA%B3%84%EC%A0%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/cloud/aws/aws-%EA%B3%84%EC%A0%95/</guid>
      <description>AWS 계정    AWS의 계정   AWS 상에서 공유하는 리소스 관리단위 단일계정과 복수계정을 활요할 수 있으며, 비교 관점에 따라 각각 운용성과 보안의 장단점이 존재   단일 계정  단순함이 장점이며, 리소스가 집약되어 있기에 초보자가 사용하기 적합 단, 여러 개의 환경을 구축하거나 운용할 때는 문제가 발생, 운용 현장의 경우에는 개발 환경만 이용 가능하고, 작업 권한이 없는 사용자가 필요 AWS는 IAM을 사용해 사용자에게 권한을 제어하고 있지만, 서버 단위 권한을 부여해야 할 경우에는 비효율적   복수 계정  복수 계쩡의 장점은 환경 단위로 계정을 나눌 수 있다는 것으로, 개발용 계정과 운영용 계정을 따로 분리해서 각기 이용하는 사용자를 나눌 수 있음 운용 측면에서 매우 큰 장점이라 할 수 있음     AWS의 감사 추적    AWS의 감사 추적  감사추적이란 시스템의 작업 이력 및 상태를 감사자가 추적할 수 있는 기록 감사추적은 크게 AWS 자체의 작업 상태와 이력, AWS 내의 리소스로 나뉘어짐   AWS 자체의 작업 상태와 이력  AWS는 브라우저로 관리 콘솔 화면 또는 API를 이용해서 작업을 진행 AWS 자체 감사 추적의 기본은 AWS Config와 AWS CloudTrail Service가 있으며 이 두가지 서비스를 통해 AWS 서비스의 감사 추적 기록을 취득할 수 있음  Config  Config.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/cloud/aws/aws_database/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/cloud/aws/aws_database/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/cloud/aws/aws_network/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/cloud/aws/aws_network/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/cloud/aws/aws_security/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/cloud/aws/aws_security/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/cloud/aws/aws_storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/cloud/aws/aws_storage/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/cloud/aws/aws%EC%9A%94%EA%B8%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/cloud/aws/aws%EC%9A%94%EA%B8%88/</guid>
      <description>AWS 요금   AWS의 요금  AWS는 기본적으로 종량 요금제이지만 일부는 무료로 이용이 가능 요금 체계는 서비스 마다 다르지만, 원칙이 존재   AWS의 요금체계  AWS는 기본적으로 종량 요금제 ( 사용한 만큼 금액을 지불하는 방식 ) 종량 과금에는 시간 기준, 횟수 기준, 용량 기준의 3가지 종류가 있으며, 이 가운데 하나 혹은 조합의 이해 요금이 측정  EC2의 경우 CPU, 메모리 등의 조합으로 한 시간단위로 이용량이 결정되어짐      네트워크 과금의 방식  네트워크 과금의 사고 방법에는 수신과 송신이 존재 외부 네트워크에서 AWS로 통신을 수신, AWS에서 외부 네트워크로 송신이라 하며 수신은 기본적으로 무료이지만 송신에 대해서는 1GB당 얼마라는 계산 방식으로 과금이 측정되어짐 수신은 무료이므로 온프레미스 서버의 데이터를 AWS에 백업하는 방식은 통신료가 무료이며, 데이터 복원 등의 이유로 그 데이터를 온프레미스로 송신할 때만 과금이 발생      횟수 기준에 따른 방식  횟수 기준에 따른 과금은 API 호출 횟수를 기준으로 계산  Amazon SQS라는 큐 서비스는 표준 큐의 경우 100만 건의 API 요청에 $0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/cloud/aws/vpc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/cloud/aws/vpc/</guid>
      <description>VPC ( Virtual Private Cloud )    Virtual Private Cloud ( VPC )  AWS 상에 프라이빗 네트워크 공간을 구축할 수 있는 서비스 VPC를 이용하면 논리적인 네트워크 분리가 가능하고 라우팅 테이블과 각종 게이트웨이의 설정이 가능 AWS의 계정 전용 가상 네트워크 서비스 VPC 내에서 각종 리소스 ( EC2, RDS, ELB 등 )을 시작할 수 있으며 다른 가상 네트워크와 논리적으로 분리되어 있음 S3, Cloudfront 등은 다른 VPC 서비스로 VPC 내에서 생성되지 않음 각 Region 별로 VPC 가 다수 존재할 수 있음 VPC 하나의 사설 IP 대역을 보유하고, 서브넷을 생성하며 사설IP 대역 일부를 나누어 줄 수 있음 허용된 IP 블록 크기는 /16( IP 65536개 )- / 28 (IP 16개 ) 권고하는 VPC CIDR 블록 ( 사설 IP 대역과 동일 )    0- 10.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/cloud/aws/%EB%B0%B0%ED%8F%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/cloud/aws/%EB%B0%B0%ED%8F%AC/</guid>
      <description>배포 ( Deploy )    배포 ( Deploy )  무중단 배포  서비스를 배포시 ( 버전 업데이트 등 ) 서버를 중단하지 않고 배포( 업데이트 )를 진행하는 것   중단배포( Ice breaking )  서비스를 배포시 서버를 중단하고 배포를 진행하는 것 ( 서버 정기 정검 )   In-Place Deployment  In-Place Deployment... In-Place Deployment    한 개의 로드밸런서가 4개의 서버로 요청을 보내고 있으며, 현재 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/cloud/aws/%EC%96%91%EC%8B%9D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/cloud/aws/%EC%96%91%EC%8B%9D/</guid>
      <description>AWS 용어 정리    AWS 기본 용어  AWS 기본 용어... Region
  AWS에서 사용하는 일종의 IDC의 집합으로 거의 모든 클라우드 서비스가 탑재되는 곳으로 다수의 Availability Zone( 가용영역 )으로 구성됨
  한 곳의 AZ의 기능이 마비되어도 다른 AZ가 기능을 수행
  전 세계 주요 대도시에는 분포되어있음
  AWS 사용자는 각 Region 마다 별도의 클라우드 망을 구축할 수 있음
   On-premise</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/cloud/aws/%EC%9A%B4%EC%98%81-%EC%84%9C%EB%B2%84%EC%9D%98-%EC%99%B8%EB%B6%80%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/cloud/aws/%EC%9A%B4%EC%98%81-%EC%84%9C%EB%B2%84%EC%9D%98-%EC%99%B8%EB%B6%80%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1/</guid>
      <description>AWS의 외부환경 구성  DNS ( Domain Name System )   DNS란 도메인네임서버를 일컫으며, 인터넷은 서버들을 유일하게 구분할 수 있는 IP주소 체계를 보다 인간이 읽게 쉽게 하기 위해 계발되었다. 흔히 우리가 알고 있는 naver.com, google.com, daum.net 모두 DNS이다. AWS에서는 Route 53을 활용해 도메인 서비스를 지원한다.   AWS Route 53    AWS의 DNS 서비스 ( 도메인 등록, DNS 라우팅, Health check ) 도메인 등록시 약 12.000원 정도 지불해야 하며, 최대 3일 정도 걸림 해당 도메인을 AWS 내 서비스 ( EC2, ELB, S3 등 ) 와 연결 할 수 있으며 AWS 외 요소들과도 연결 가능 도메인 생성 후 레코드 세트를 생성하여 하위 도메인을 등록할 수 있음 레코드 세트 등록시에는 IP 주소, 도메인, ‘Alias’ 등을 지정하여 쿼리를 라우팅할 수 있음   Route 53의 라우팅 정책  Simple : 동일 레코드 내에 다수의 IP를 지정하여 라우팅 가능, 값을 다수 지정한 경우 무작위로 반환함 Weighted : Region 별 부하 분산 가능, 각 가중치를 가진 동일한 이름의 A 레코드를 만들어 IP를 다르게 줌 Latency-based : 지연 시간이 가장 적은, 즉 응답시간이 가장 빠른 리전으로 쿼리를 요청 Failover : A/S 설정에서 사용됨, Main과 DR로 나누어 Main 장애시 DR로 쿼리 Geolocation : 각 지역을 기반으로 가장 가까운 리전으로 쿼리 수행, 레코드 생성시 지역을 지정할 수 있음 Geo-proximity : Traffic flow를 이용한 사용자 정의 DNS 쿼리 생성 가능 Multi-value answer : 다수의 IP를 지정한다는 것은 simpl와 비슷하지만 health check가 가능 ( 실패시 자동 Failover )     AWS Route 사용방법.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/hidden/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/hidden/</guid>
      <description>This page is hidden in menu Quondam non pater est dignior ille Eurotas Latent te facies Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.
 Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona O fallor in sustinui iussorum equidem.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/programing/code/python/python/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/programing/code/python/python/</guid>
      <description>Python 내장함수  ...abs abs(x)는 어떤 숫자를 입력받았을 때, 그 숫자의 절댓값을 돌려주는 함수
&amp;gt;&amp;gt;&amp;gt; abs(3)3&amp;gt;&amp;gt;&amp;gt; abs(-3)3   all all(x)는 반복 가능한(iterable) 자료형 x를 입력 인수로 받으며 이 x가 모두 참이면 True, 거짓이 하나라도 있으면 False를 반환
※ 반복 가능한 자료형이란 for문으로 그 값을 출력할 수 있는 것을 의미한다. 리스트, 튜플, 문자열, 딕셔너리, 집합 등이 있다.
&amp;gt;&amp;gt;&amp;gt; all([1, 2, 3])True&amp;gt;&amp;gt;&amp;gt; all([1, 2, 3, 0])False  any any(x)는 x 중 하나라도 참이 있으면 True를 돌려주고, x가 모두 거짓일 때에만 False를 돌려준다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/django/basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/django/basic/</guid>
      <description>Django    Django   파이썬으로 만들어진 무료 오픈소스 웹 애플리케이션 프레임워크 모델&amp;ndash;뷰&amp;ndash;컨트롤러 ( MVC ) 패턴을 따름 장고는 컴포넌트의 재사용 및 플러그인화 가능성을, 빠른 개발을 위해 계발 웹 개발 시 많이 사용되며, 번거로운 요소들을 새로 개발할 필요 없이 내장된 기능만을 이용해 빠른 개발이 가능   MTV ( Model-Template-View )    Model
 데이터에 관한 정보를 담으며, 데이터에 대한 접근, 검증, 작동과 데이터 사이의 관계를 정의하며, 각각의 모델은 데이터베이스에서 테이블에 해당    Template</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/django/django/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/django/django/</guid>
      <description>Djnago  Djnago 설치  설치환경   Ubuntu 18.04
  mysql 5.7
  python 3.6.8
  pip3 9.0.3
  django 2.1
   Ubuntu 설정   apt update -y
  apt upgrade -y
  apt install python3 -y
  apt install python3-pip -y
  apt install gcc -y
  apt install python-dev -y
  apt install libmysqlclient-dev -y</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/django/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/django/test/</guid>
      <description>Django Project   Django Boardapp project  모델을 구성하기에 앞서 django에서 지원하는 admin을 사용하기 위해 기본적인 database를 받아온다.
(ve) $ ./manage.py migrate DB 테이블 생성
# User tableALTER TABLE auth_userADD COLUMN phone VARCHAR(45) NOT NULL AFTER date_joined,ADD COLUMN date_of_birth DATETIME NOT NULL AFTER phone,CHANGE COLUMN date_joined date_joined DATETIME NOT NULL AFTER email,CHANGE COLUMN first_name first_name VARCHAR(30) NULL AFTER is_active,CHANGE COLUMN is_staff is_staff TINYINT(1) NULL,CHANGE COLUMN is_active is_active TINYINT(1) NULL;# Board table## board_categoriescreate table board_categories(id int(10) not null auto_increment,category_type varchar(45) not null default &amp;#39;Normal&amp;#39;,category_code varchar(100) not null,category_name varchar(100) not null,category_desc varchar(200) not null,list_count int(10) default &amp;#39;20&amp;#39;,authority int(1) default &amp;#39;0&amp;#39;,creation_date datetime default current_timestamp,last_update_date datetime default null,primary key(id))engine=InnoDB default CHARSET=utf8;## boardscreate table boards(id int(10) not null auto_increment,category_id int(10) not null,user_id int(10) not null,title varchar(300) not null,content text not null,registered_date datetime default current_timestamp,last_update_date datetime default null,view_count int(10) default &amp;#39;0&amp;#39;,image varchar(255) default null,primary key(id),key board_category_fk_idx(category_id),key board_user_fk_idx(user_id),constraint board_category_fk foreign key(category_id) references board_categories(id) on delete no action on update no action,constraint board_user_fk foreign key(user_id) references auth_user(id) on delete no action on update no action)engine=InnoDB default CHARSET=utf8;## board_repliescreate table board_replies(id int(10) not null auto_increment,article_id int(10) not null,user_id int(10) not null,`level` tinyint(1) default &amp;#39;1&amp;#39;,content text not null,reference_reply_id int(10) default &amp;#39;0&amp;#39;,registered_date datetime default current_timestamp,last_update_date datetime default null,primary key(id),key user_reply_fk_idx(user_id),key article_reply_fk_idx(article_id),constraint article_reply_fk foreign key(article_id) references boards(id) on delete no action on update no action,constraint user_reply_fk foreign key(user_id) references auth_user(id) on delete no action on update no action)engine=InnoDB default CHARSET=utf8;## board_likescreate table board_likes(id int(10) not null auto_increment,article_id int(10) not null,user_id int(11) not null,registered_date datetime default current_timestamp,primary key(id),key like_article_fk_idx(article_id),key like_user_fk_idx(user_id),constraint like_article_fk foreign key(article_id) references boards(id) on delete no action on update no action,constraint like_user_fk foreign key(user_id) references auth_user(id) on delete no action on update no action)engine=InnoDB default CHARSET=utf8;pip3 install Pillow</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/golang/ttt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/golang/ttt/</guid>
      <description>Go   Golang 설치 Go에서 OS맞는 패키지를 설치
var a int = 1var b float32 = 1.3var c float32 = a + b</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/network/network_equipment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/network/network_equipment/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/network/%E3%84%B4-packet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/network/%E3%84%B4-packet/</guid>
      <description>네트워크 패킷 ( Network Packet )    패킷이란 데이터의 묶음 단위로 한번에 전송할 데이터의 크기
  제 3계층 이상 ( Network 계층 ) 에서는 이 데이터의 묶음을 패킷이라고 부르며, 제 2계층에서는 프레임( Frame )
  패킷의 크기는 네트워크의 종류에 따라 크기가 다름
  패킷을 이렇게 나눠 보내는 이유는 컴퓨터는 동시다발적으로 데이터를 전송하는 데, 한 데이터에게만 데이터를 줄 경우, 한 컴퓨터와의 통신밖에 하지 못하기에, 데이터를 나눠 모두에게 통신할 수 있게 하며, 중간에 에러가 날 경우를 대비</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/network/%E3%84%B4-portnumber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/network/%E3%84%B4-portnumber/</guid>
      <description>TCP/ UDP 포트 번호 정리  기본적인 포트번호    Well-known port : 0 ~ 1023
  Registered port : 1024 ~ 49151
  Dynamic port : 49152 ~ 65535
    Port Tables...  Register Port  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/security/%EB%B0%A9%ED%99%94%EB%B2%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/security/%EB%B0%A9%ED%99%94%EB%B2%BD/</guid>
      <description>방화벽 (CentOS - firewalld)    리눅스의 방화벽
 커널의 Netfilter 모듈에 기초를 두고 있는 하나의 프로그램 방화벽은 일반적으로 내부와 외부 네트워크의 경계 지점에 위치 기본적으로 들어오고 나가는 패킷에 대해 지정된 정책과 규칙을 사용 허용(Accept)과 거절(Reject)이라는 행동을 통해 모든 패킷을 통제       방화벽의 종류
 패킷 필터링 방화벽  - 제 1세대 방화벽 - 레이어 1~4에서 사용 - 단순하기 때문에 빠르고 효과적 - 5~7계층 대응 불가  Stateful 방화벽  - 제 2세대 방화벽 - 패킷의 연결 상태를 관찰 - 메모리에서 상태 테이블 사용 - DoS 공격과 같은 메모리 잠식 공격에 취약  **애플리케이션 레이어 방화벽 **  - 제 3세대 방화벽 - 레이어7까지 패킷 검사와 필터링 - 고사양의 장비가 필요      방화벽의 구성요소   규칙(Rule) : Netfilter에서 가장 핵심적인 구성 요소로서 하나 또는 그 이상 일치돼야 할 항목들로 구성되며, 패킷이 이러한 규칙이 일치(match)할 경우 타겟을 이용해 구체적인 행동 사항을 지정한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/security/%EB%B3%B4%EC%95%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/security/%EB%B3%B4%EC%95%88/</guid>
      <description>Network Security   Hacking Process  확인 정보 ( OS 버전, 응용 프로그램, IP주소, 도메인 )  정보수집  정보 수집...  구글 검색    intitle : [검색어] - 탭 제목에 포함된 내용으로 검색
  filetype : [검색어] - 특정 파일 확장자로 검색
  site : [검색어] - 특정 도메인 주소 검색
  inurl : [검색어] - URL에 포함된 문자 검색</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/security/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%86%B5%ED%95%A9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/security/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%86%B5%ED%95%A9/</guid>
      <description>시스템통합 관리 침입 탐지 시스템(IDS) &amp;ndash; Snort 이용    주된 기능
  탐지(Detection)
  잘못된 패킷을 감지하면 사용자에게 알림(주체적으로 처리하지 X, only 안내)
       탐지 종류 2가지
  (1)오용 탐지	알고 있는 것 탐지
  (2)이상 탐지	모르는 것도 탐지(100% 탐지 X)
  너무 민감하게 처리하면 필요한 정보도 차단하는 실수를 할 수 있음
       설치위치 ( 성능이 달라짐 )</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/system/linux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/system/linux/</guid>
      <description>Linux   Linux 기초   유닉스 기반의 컴퓨터 운영체제의 한 종류 핀란드 헬싱키 대학의 대학원생 리누스 토발즈가 1991년에 개발 오픈 소스의 운영체제 대표적인 리눅스 기관 GNU 높은 이식성과 확정성 ( C언어 기반 ) 안전성과 신뢰성 ( 국제적이고 개방적으로 개발되었기 때문에 문제점에 대한 대처가 빠름 ) 계층적 파일 시스템 ( 최상위 디렉토리가 존재하고 모든 것들은 해당 디렉토리 하부에 존재 )   유닉스 운영체제 종류  리눅스의 구성요소   명령어 : 사용자가 원하는 프로그램을 콜링</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/system/%E3%84%B4%EB%B0%A9%ED%99%94%EB%B2%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/system/%E3%84%B4%EB%B0%A9%ED%99%94%EB%B2%BD/</guid>
      <description>방화벽 (CentOS - firewalld)    리눅스의 방화벽
 커널의 Netfilter 모듈에 기초를 두고 있는 하나의 프로그램 방화벽은 일반적으로 내부와 외부 네트워크의 경계 지점에 위치 기본적으로 들어오고 나가는 패킷에 대해 지정된 정책과 규칙을 사용 허용(Accept)과 거절(Reject)이라는 행동을 통해 모든 패킷을 통제       방화벽의 종류
 패킷 필터링 방화벽  - 제 1세대 방화벽 - 레이어 1~4에서 사용 - 단순하기 때문에 빠르고 효과적 - 5~7계층 대응 불가  Stateful 방화벽  - 제 2세대 방화벽 - 패킷의 연결 상태를 관찰 - 메모리에서 상태 테이블 사용 - DoS 공격과 같은 메모리 잠식 공격에 취약  **애플리케이션 레이어 방화벽 **  - 제 3세대 방화벽 - 레이어7까지 패킷 검사와 필터링 - 고사양의 장비가 필요      방화벽의 구성요소   규칙(Rule) : Netfilter에서 가장 핵심적인 구성 요소로서 하나 또는 그 이상 일치돼야 할 항목들로 구성되며, 패킷이 이러한 규칙이 일치(match)할 경우 타겟을 이용해 구체적인 행동 사항을 지정한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/system/%E3%84%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%86%B5%ED%95%A9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/system/%E3%84%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%86%B5%ED%95%A9/</guid>
      <description>시스템통합 관리 침입 탐지 시스템(IDS) &amp;ndash; Snort 이용    주된 기능
  탐지(Detection)
  잘못된 패킷을 감지하면 사용자에게 알림(주체적으로 처리하지 X, only 안내)
       탐지 종류 2가지
  (1)오용 탐지	알고 있는 것 탐지
  (2)이상 탐지	모르는 것도 탐지(100% 탐지 X)
  너무 민감하게 처리하면 필요한 정보도 차단하는 실수를 할 수 있음
       설치위치 ( 성능이 달라짐 )</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/web/css/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/web/css/</guid>
      <description>#css태그 {스타일}*{}전체선택.클래스명{스타일}&amp;lt;h1 class=&amp;quot;클래스명&amp;quot;&amp;gt;id 선택자#아이디명{스타일}단위: em, ex, px, ptfont-family: &amp;lt;글꼴 이름[,&amp;lt;글꼴 이름&amp;gt;, &amp;lt;글꼴 이름&amp;gt;];font-size: &amp;lt;절대 크기&amp;gt; | &amp;lt;상대 크기&amp;gt; | &amp;lt;크기&amp;gt; | &amp;lt;백분율&amp;gt;font-weight: noraml | bold | bolder | lighter | 100 | 200 ...font-variant: normal | small-capsfont-style: normal | italic | obliquefont: .....#text 스타일color: &amp;lt;색상&amp;gt;rgb(0,200,0). rgba(n,n,n,n), #0000ff, bluetext-decoration: none | underline | overline | line-throughtext-transform: none | capitalize | uppercase | lowercase | full-widthtext-shadow: none | &amp;lt;가로 거리&amp;gt; &amp;lt;세로 거리&amp;gt; &amp;lt;번짐 정도&amp;gt; &amp;lt;색상&amp;gt;white-space: normal | nowrap | pre | pre-line | pre-wrapletter-spacing: normal | &amp;lt;크기&amp;gt;word-spacing: normal | &amp;lt;크기&amp;gt;#문단 스타일direction: ltr | rtlltr 왼쪽에서 오른쪽으로 표시rtl 오른쪽에서 왼쪽으로 표시text-align: start | end | left | right | center | justtify | match-parenttext-justfy: auto | none | inter-word | distributetext-indent: &amp;lt;크기&amp;gt; | &amp;lt;백분율&amp;gt; 들여쓰기text-overflow: clip | ellipsis 너치는 텍스트를 자르기 | .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/web/html/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/web/html/</guid>
      <description>HTML   HTML 기본양식...&amp;lt;head&amp;gt;&amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;&amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;   태그   줄 바꾸기 &amp;lt;br&amp;gt; 구분선 &amp;lt;hr&amp;gt; 제목 &amp;lt;h1- h6&amp;gt; &amp;lt;/hn&amp;gt; 문단 &amp;lt;p&amp;gt; &amp;lt;/p&amp;gt; 입력을 그대로 표시하는 태그 &amp;lt;pre&amp;gt; &amp;lt;/pre&amp;gt; 인용문을 넣는 태그 &amp;lt;blockquote&amp;gt; &amp;lt;/blockquote&amp;gt; 인용문을 인 라인에 넣는 태그 &amp;lt;q&amp;gt; &amp;lt;/q&amp;gt;  text   밑줄 &amp;lt;u&amp;gt; &amp;lt;/u&amp;gt; 굵은 텍스트 &amp;lt;b&amp;gt; &amp;lt;/b&amp;gt; 텍스트 강조 &amp;lt;strong&amp;gt; &amp;lt;/strong&amp;gt; 형광펜 텍스트 &amp;lt;mark&amp;gt;&amp;lt;/mark&amp;gt; 동아시아 글자 표시 rt는 읽는 방법표기법 &amp;lt;ruby&amp;gt; &amp;lt;rt&amp;gt; &amp;lt;/rt&amp;gt; &amp;lt;/ruby&amp;gt; 이탤릭 체 Emphasized tag &amp;lt;em&amp;gt; &amp;lt;/em&amp;gt; 줄 찍 &amp;lt;del&amp;gt; &amp;lt;/del&amp;gt; 인설트 태그 &amp;lt;ins&amp;gt; &amp;lt;/ins&amp;gt; This is &amp;lt;sub&amp;gt; sub &amp;lt;sub&amp;gt; text &amp;lt;/sub&amp;gt; &amp;lt;/sub&amp;gt; &amp;lt; &amp;gt; 태그 요소 &amp;amp;lt; &amp;amp;gt; 스페이스바 &amp;amp;nbsp; 약자 속성, title 속성을 함께 사용가능 &amp;lt;addr&amp;gt; &amp;lt;/addr&amp;gt; 포스트에서 참고 내용을 표시 &amp;lt;cite&amp;gt; &amp;lt;/cite&amp;gt; 컴퓨터 인식코드 &amp;lt;code&amp;gt; &amp;lt;/code&amp;gt; 키보드, 음성 입력 &amp;lt;kbd&amp;gt; &amp;lt;/kbd&amp;gt; 작게 표시 (부가정보) &amp;lt;small&amp;gt; &amp;lt;/small&amp;gt; 아래 첨자 &amp;lt;sub&amp;gt; &amp;lt;/sub&amp;gt; 위 첨자 &amp;lt;sup&amp;gt; &amp;lt;/sup&amp;gt; 취소선 &amp;lt;s&amp;gt; &amp;lt;/s&amp;gt;  List  #list&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; &amp;lt;/li&amp;gt;&amp;lt;li&amp;gt; &amp;lt;/li&amp;gt;&amp;lt;li&amp;gt; &amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;ul의 종류: disc, circle, sqaure, none&amp;lt;ol&amp;gt;&amp;lt;li&amp;gt; &amp;lt;/li&amp;gt;&amp;lt;li&amp;gt; &amp;lt;/li&amp;gt;&amp;lt;li&amp;gt; &amp;lt;/li&amp;gt;&amp;lt;ol&amp;gt;ol의 종류: 1, i, l, a, A, none&amp;lt;dl&amp;gt;&amp;lt;dt&amp;gt; &amp;lt;/dt&amp;gt;&amp;lt;dd&amp;gt; &amp;lt;/dd&amp;gt;&amp;lt;dt&amp;gt; &amp;lt;/dt&amp;gt;&amp;lt;dd&amp;gt; &amp;lt;/dd&amp;gt;&amp;lt;/dl&amp;gt;&amp;lt;h1 style= &amp;#34; 설정 값 &amp;#34; &amp;gt; &amp;lt;/h1&amp;gt;p {color : xx;background: xx;adding: xx;}xx-color: rgb(x,x,x);#xxxxxx;hsl(x,x%,x%)  링크태그   인터넷 링크 &amp;lt;a href=&amp;#34;링크할 주소&amp;#34; [속성=&amp;#34;속성 값&amp;#34;]&amp;gt; &amp;lt;/a&amp;gt;&amp;lt;a href =&amp;#34;도메인 주소&amp;#34;&amp;gt; &amp;lt;/a&amp;gt;a 태그 안에서 사용 가능한 요소href링크한 문서나 사이트의 주소를 입력target링크한 내용이 표시될 위치를 지정target =&amp;#34;_blank&amp;#34; 링크 내용이 새 창이나 새 탭에서 열림열림표시전체 화면에 표시download링크한 내용을 보여주는 것이 아니라 다운로드rel현재 문서와 링크한 문서의 관계를 알려줌hreflang링크한 문서의 언어를 지정type링크한 문서의 파일 유형을 알려줌a 대신 iframe을 사용시 액자식 구성 사용 가능앵커 기능&amp;lt;태그 id=&amp;#34;앵커 이름&amp;#34;&amp;gt; 텍스트 또는 이미지&amp;lt;/태그&amp;gt;&amp;lt;a href=&amp;#34;#앵커 이름&amp;#34;&amp;gt;텍스트 또는 이미지&amp;lt;/a&amp;gt;  이미지 링크  &amp;lt;img src=&amp;quot;이미지의 경로&amp;quot; 속성값=&amp;quot;&amp;quot;&amp;gt;width=&amp;quot;n&amp;quot;이미지의 넓이를 지정height=&amp;quot;n&amp;quot;이미지의 높이를 지정alt=&amp;quot;설명&amp;quot;이미지의 설명을 지정&amp;lt;figure&amp;gt; 요소 &amp;lt;/figure&amp;gt;&amp;lt;figcaption&amp;gt; 설명 &amp;lt;/figcaption&amp;gt;요소로 묶은 것에 대한 설명을 붙임&amp;lt;map name=&amp;quot;이름&amp;quot;&amp;gt;&amp;lt;area&amp;gt;&amp;lt;area shape=&amp;quot;rect&amp;quot; coords=&amp;quot;n,n,n,n&amp;quot; href=&amp;quot;주소&amp;quot; alt=&amp;quot;설명&amp;quot;&amp;gt;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/%EC%A0%84%EC%A0%84/git/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/%EC%A0%84%EC%A0%84/git/</guid>
      <description>Git&amp;amp;&amp;amp; Github  깃 ( git )    Git 공식 홈페이지 에서 다운로드
  형상 관리 도구 ( Configuration Management Tool )인 분산형 관리 시스템
  무료, 공개소프트웨어 서비스
  소스코드를 주고 받을 필요 없이, 같은 파일을 여러 명이 동시에 작업하는 병렬 개발이 가능
  분산 버전관리이기 때문에 인터넷이 연결되지 않은 곳에서도 개발을 진행할 수 있으며, 중앙 저장소가 날라가벌도 다시 원상복구가 가능
     git의 특징   버전관리   깃에서 버전이란 문서를 수정하고 저장할 때마다 생기는 지점</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/%EC%A0%84%EC%A0%84/hugo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/%EC%A0%84%EC%A0%84/hugo/</guid>
      <description>Hugo  휴고 다운로드
   So cutey
  Hugo는 Go언어를 기반으로 Go 언어를 이용한 프로그램 사용 및 수정
  Markdown으로 글을 작성
  git을 활용한 글 관리 및 버전 관리
     Hugo 적용    Hugo 환경변수 등록
  휴고 사이트 시작
  hugo new site testprojectcd testprojecthugo server -D  테마 적용    Hugo 테마 다운로드</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/%EC%A0%84%EC%A0%84/sdn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/%EC%A0%84%EC%A0%84/sdn/</guid>
      <description>SDN   SDN ( Software Defined Networking : 소프트웨어 정의 네트워킹 )    기존의 네트워크 인프라가 가지고 있던 문제를 해결하기 위해서 나온 개념
  기존의 네트워크 인프라를 구성하는 네트워크 장비들은 하나의 장비에 HW OS APP이 모두 들어가 있었기 때문에 장비 하나하나가 복잡한 기능을 모두 가지고 있었고 장비 자체의 사양도 높아야 했다. 그러다보니 장비마다 비용도 비싸지고 장비를 하나하나 설정해야하는 문제점들이 있었다.
  SDN은 기존의 장비의 HW와 OS APP 부분을 분리하여 장비 하나하나는 HW부분만을 담당하고 SW적인 부분은 중앙의 컨트롤러에서 제어한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%84%A4%EA%B3%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%84%A4%EA%B3%84/</guid>
      <description>플랫폼 ( Platform )  애플리케이션을 구동시키는 데 필요한 하드웨어와 소프트웨어의 결합 동일 플랫폼 내에서의 상호 호환이 가능하도록 만들어진 결합체를 의미 소프트웨어의 개발과 운영비용을 감소시키고, 생산성이 향상 동일 플랫폼의 커뮤니티가 형성되고 네트워크 효과를 유발  플랫폼의 유형  유형 | 설명 | 사례------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------싱글 사이드 플랫폼 (Single-Side platform) | 제휴 관계를 통해 소비자와 공급자를 연결하는 형태 | 아이튠즈, 안드로이드 마켓투 사이드 플랫폼 (Two-Side Platform) | 두 그룹을 중개하고 모두에게 개방하는 형태 | 소개팅 앱멀티 사이트 플랫폼 (Multi-Side Platform) | 다양한 이해관계 그룹을 연결하여 중개하는 형태 | 페이스북, 인스타그램 플랫폼의 기능 분석  플랫폼 성능 분석을 통해 사용자의 서비스 이용 시 적정성을 알 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B3%84%EB%B0%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B3%84%EB%B0%9C/</guid>
      <description>데이터 입출력 구현  자료 구조 ( Data Structure )    컴퓨터상 자료를 효율적으로 저장하기 위해 만들어진 논리적인 구조
  자료 구조의 현명한 선택을 통해 효율적인 알고리즘을 사용할 수 있어 성능을 향샹
   자료 구조의 분류    자료 구조의 분류는 선형 구조와 비선형 구조로 크게 나뉜다
  선형 구조에는 배열, 연결 리스트, 스택, 큐 등이 있다
  비선형 구조엔느 트리, 그래프 등이 존재</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B5%AC%EC%B6%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B5%AC%EC%B6%95/</guid>
      <description>#DBMS (Database Management System)
 - 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고 데이터베이스를 관리해주는 소프트웨어#DBMS의 필수 3기능------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------유형 | 설명------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------데이터 정의 (Data Definition) | 다양한 응용 프로그램과 데이터베이스가 서로 인터페이스를 할 수 있는 방법을 제공하는 기능데이터 조작 (Data Manipulation) | 사용자와 데이터베이스 사이의 인터페이스를 위한 수단을 제공하는 기능데이터 제어 (Data Cotrol) | 공용 목적으로 관리되는 데이터베이스 내용에 대해 상상 정확성과 안정성을 유지 할 수 있도록 데이터를 제어 하는 기능------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#데이터 모델 (Data Model)- 현살 세계의 정보를 인간과 컴퓨터가 이해할 수 있도록 추상화하여 표현한 모델이다- 데이터 모델 절차는 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델 순이다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4-%ED%99%9C%EC%9A%A9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4-%ED%99%9C%EC%9A%A9/</guid>
      <description>ㅎㅇ</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/docs/study/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/5.-%EC%A0%95%EB%B3%B4%EC%84%B8%EC%8A%A4%ED%85%9C-%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/docs/study/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/5.-%EC%A0%95%EB%B3%B4%EC%84%B8%EC%8A%A4%ED%85%9C-%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/</guid>
      <description>ㅎㅇ</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mung0001.github.io/hidden/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mung0001.github.io/hidden/</guid>
      <description>This page is hidden in menu Quondam non pater est dignior ille Eurotas Latent te facies Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.
 Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona O fallor in sustinui iussorum equidem.</description>
    </item>
    
  </channel>
</rss>